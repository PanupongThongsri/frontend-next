{
  "version": 3,
  "sources": [],
  "sections": [
    {"offset": {"line": 4, "column": 0}, "map": {"version":3,"sources":["file:///Users/best/Documents/admin-frontend-next/www/node_modules/%40rc-component/form/es/FieldContext.js"],"sourcesContent":["import warning from \"@rc-component/util/es/warning\";\nimport * as React from 'react';\nexport const HOOK_MARK = 'RC_FORM_INTERNAL_HOOKS';\n\n// eslint-disable-next-line @typescript-eslint/no-explicit-any\nconst warningFunc = () => {\n  warning(false, 'Can not find FormContext. Please make sure you wrap Field under Form.');\n};\nconst Context = /*#__PURE__*/React.createContext({\n  getFieldValue: warningFunc,\n  getFieldsValue: warningFunc,\n  getFieldError: warningFunc,\n  getFieldWarning: warningFunc,\n  getFieldsError: warningFunc,\n  isFieldsTouched: warningFunc,\n  isFieldTouched: warningFunc,\n  isFieldValidating: warningFunc,\n  isFieldsValidating: warningFunc,\n  resetFields: warningFunc,\n  setFields: warningFunc,\n  setFieldValue: warningFunc,\n  setFieldsValue: warningFunc,\n  validateFields: warningFunc,\n  submit: warningFunc,\n  getInternalHooks: () => {\n    warningFunc();\n    return {\n      dispatch: warningFunc,\n      initEntityValue: warningFunc,\n      registerField: warningFunc,\n      useSubscribe: warningFunc,\n      setInitialValues: warningFunc,\n      destroyForm: warningFunc,\n      setCallbacks: warningFunc,\n      registerWatch: warningFunc,\n      getFields: warningFunc,\n      setValidateMessages: warningFunc,\n      setPreserve: warningFunc,\n      getInitialValue: warningFunc,\n      setBatchUpdate: warningFunc\n    };\n  }\n});\nexport default Context;"],"names":[],"mappings":";;;;;;AAAA;AACA;;;AACO,MAAM,YAAY;AAEzB,8DAA8D;AAC9D,MAAM,cAAc;IAClB,IAAA,yNAAO,EAAC,OAAO;AACjB;AACA,MAAM,UAAU,WAAW,GAAE,+NAAmB,CAAC;IAC/C,eAAe;IACf,gBAAgB;IAChB,eAAe;IACf,iBAAiB;IACjB,gBAAgB;IAChB,iBAAiB;IACjB,gBAAgB;IAChB,mBAAmB;IACnB,oBAAoB;IACpB,aAAa;IACb,WAAW;IACX,eAAe;IACf,gBAAgB;IAChB,gBAAgB;IAChB,QAAQ;IACR,kBAAkB;QAChB;QACA,OAAO;YACL,UAAU;YACV,iBAAiB;YACjB,eAAe;YACf,cAAc;YACd,kBAAkB;YAClB,aAAa;YACb,cAAc;YACd,eAAe;YACf,WAAW;YACX,qBAAqB;YACrB,aAAa;YACb,iBAAiB;YACjB,gBAAgB;QAClB;IACF;AACF;uCACe","ignoreList":[0],"debugId":null}},
    {"offset": {"line": 59, "column": 0}, "map": {"version":3,"sources":["file:///Users/best/Documents/admin-frontend-next/www/node_modules/%40rc-component/form/es/ListContext.js"],"sourcesContent":["import * as React from 'react';\nconst ListContext = /*#__PURE__*/React.createContext(null);\nexport default ListContext;"],"names":[],"mappings":";;;;AAAA;;AACA,MAAM,cAAc,WAAW,GAAE,+NAAmB,CAAC;uCACtC","ignoreList":[0],"debugId":null}},
    {"offset": {"line": 71, "column": 0}, "map": {"version":3,"sources":["file:///Users/best/Documents/admin-frontend-next/www/node_modules/%40rc-component/form/es/utils/typeUtil.js"],"sourcesContent":["export function toArray(value) {\n  if (value === undefined || value === null) {\n    return [];\n  }\n  return Array.isArray(value) ? value : [value];\n}\nexport function isFormInstance(form) {\n  return form && !!form._init;\n}"],"names":[],"mappings":";;;;;;AAAO,SAAS,QAAQ,KAAK;IAC3B,IAAI,UAAU,aAAa,UAAU,MAAM;QACzC,OAAO,EAAE;IACX;IACA,OAAO,MAAM,OAAO,CAAC,SAAS,QAAQ;QAAC;KAAM;AAC/C;AACO,SAAS,eAAe,IAAI;IACjC,OAAO,QAAQ,CAAC,CAAC,KAAK,KAAK;AAC7B","ignoreList":[0],"debugId":null}},
    {"offset": {"line": 92, "column": 0}, "map": {"version":3,"sources":["file:///Users/best/Documents/admin-frontend-next/www/node_modules/%40rc-component/form/es/utils/messages.js"],"sourcesContent":["const typeTemplate = \"'${name}' is not a valid ${type}\";\nexport const defaultValidateMessages = {\n  default: \"Validation error on field '${name}'\",\n  required: \"'${name}' is required\",\n  enum: \"'${name}' must be one of [${enum}]\",\n  whitespace: \"'${name}' cannot be empty\",\n  date: {\n    format: \"'${name}' is invalid for format date\",\n    parse: \"'${name}' could not be parsed as date\",\n    invalid: \"'${name}' is invalid date\"\n  },\n  types: {\n    string: typeTemplate,\n    method: typeTemplate,\n    array: typeTemplate,\n    object: typeTemplate,\n    number: typeTemplate,\n    date: typeTemplate,\n    boolean: typeTemplate,\n    integer: typeTemplate,\n    float: typeTemplate,\n    regexp: typeTemplate,\n    email: typeTemplate,\n    url: typeTemplate,\n    hex: typeTemplate\n  },\n  string: {\n    len: \"'${name}' must be exactly ${len} characters\",\n    min: \"'${name}' must be at least ${min} characters\",\n    max: \"'${name}' cannot be longer than ${max} characters\",\n    range: \"'${name}' must be between ${min} and ${max} characters\"\n  },\n  number: {\n    len: \"'${name}' must equal ${len}\",\n    min: \"'${name}' cannot be less than ${min}\",\n    max: \"'${name}' cannot be greater than ${max}\",\n    range: \"'${name}' must be between ${min} and ${max}\"\n  },\n  array: {\n    len: \"'${name}' must be exactly ${len} in length\",\n    min: \"'${name}' cannot be less than ${min} in length\",\n    max: \"'${name}' cannot be greater than ${max} in length\",\n    range: \"'${name}' must be between ${min} and ${max} in length\"\n  },\n  pattern: {\n    mismatch: \"'${name}' does not match pattern ${pattern}\"\n  }\n};"],"names":[],"mappings":";;;;AAAA,MAAM,eAAe;AACd,MAAM,0BAA0B;IACrC,SAAS;IACT,UAAU;IACV,MAAM;IACN,YAAY;IACZ,MAAM;QACJ,QAAQ;QACR,OAAO;QACP,SAAS;IACX;IACA,OAAO;QACL,QAAQ;QACR,QAAQ;QACR,OAAO;QACP,QAAQ;QACR,QAAQ;QACR,MAAM;QACN,SAAS;QACT,SAAS;QACT,OAAO;QACP,QAAQ;QACR,OAAO;QACP,KAAK;QACL,KAAK;IACP;IACA,QAAQ;QACN,KAAK;QACL,KAAK;QACL,KAAK;QACL,OAAO;IACT;IACA,QAAQ;QACN,KAAK;QACL,KAAK;QACL,KAAK;QACL,OAAO;IACT;IACA,OAAO;QACL,KAAK;QACL,KAAK;QACL,KAAK;QACL,OAAO;IACT;IACA,SAAS;QACP,UAAU;IACZ;AACF","ignoreList":[0],"debugId":null}},
    {"offset": {"line": 148, "column": 0}, "map": {"version":3,"sources":["file:///Users/best/Documents/admin-frontend-next/www/node_modules/%40rc-component/form/es/utils/validateUtil.js"],"sourcesContent":["import RawAsyncValidator from '@rc-component/async-validator';\nimport * as React from 'react';\nimport warning from \"@rc-component/util/es/warning\";\nimport { defaultValidateMessages } from \"./messages\";\nimport { merge } from \"@rc-component/util/es/utils/set\";\n\n// Remove incorrect original ts define\nconst AsyncValidator = RawAsyncValidator;\n\n/**\n * Replace with template.\n *   `I'm ${name}` + { name: 'bamboo' } = I'm bamboo\n */\nfunction replaceMessage(template, kv) {\n  return template.replace(/\\\\?\\$\\{\\w+\\}/g, str => {\n    if (str.startsWith('\\\\')) {\n      return str.slice(1);\n    }\n    const key = str.slice(2, -1);\n    return kv[key];\n  });\n}\nconst CODE_LOGIC_ERROR = 'CODE_LOGIC_ERROR';\nasync function validateRule(name, value, rule, options, messageVariables) {\n  const cloneRule = {\n    ...rule\n  };\n\n  // Bug of `async-validator`\n  // https://github.com/react-component/field-form/issues/316\n  // https://github.com/react-component/field-form/issues/313\n  delete cloneRule.ruleIndex;\n\n  // https://github.com/ant-design/ant-design/issues/40497#issuecomment-1422282378\n  AsyncValidator.warning = () => void 0;\n  if (cloneRule.validator) {\n    const originValidator = cloneRule.validator;\n    cloneRule.validator = (...args) => {\n      try {\n        return originValidator(...args);\n      } catch (error) {\n        console.error(error);\n        return Promise.reject(CODE_LOGIC_ERROR);\n      }\n    };\n  }\n\n  // We should special handle array validate\n  let subRuleField = null;\n  if (cloneRule && cloneRule.type === 'array' && cloneRule.defaultField) {\n    subRuleField = cloneRule.defaultField;\n    delete cloneRule.defaultField;\n  }\n  const validator = new AsyncValidator({\n    [name]: [cloneRule]\n  });\n  const messages = merge(defaultValidateMessages, options.validateMessages);\n  validator.messages(messages);\n  let result = [];\n  try {\n    await Promise.resolve(validator.validate({\n      [name]: value\n    }, {\n      ...options\n    }));\n  } catch (errObj) {\n    if (errObj.errors) {\n      result = errObj.errors.map(({\n        message\n      }, index) => {\n        const mergedMessage = message === CODE_LOGIC_ERROR ? messages.default : message;\n        return /*#__PURE__*/React.isValidElement(mergedMessage) ?\n        /*#__PURE__*/\n        // Wrap ReactNode with `key`\n        React.cloneElement(mergedMessage, {\n          key: `error_${index}`\n        }) : mergedMessage;\n      });\n    }\n  }\n  if (!result.length && subRuleField && Array.isArray(value) && value.length > 0) {\n    const subResults = await Promise.all(value.map((subValue, i) => validateRule(`${name}.${i}`, subValue, subRuleField, options, messageVariables)));\n    return subResults.reduce((prev, errors) => [...prev, ...errors], []);\n  }\n\n  // Replace message with variables\n  const kv = {\n    ...rule,\n    name,\n    enum: (rule.enum || []).join(', '),\n    ...messageVariables\n  };\n  const fillVariableResult = result.map(error => {\n    if (typeof error === 'string') {\n      return replaceMessage(error, kv);\n    }\n    return error;\n  });\n  return fillVariableResult;\n}\n\n/**\n * We use `async-validator` to validate the value.\n * But only check one value in a time to avoid namePath validate issue.\n */\nexport function validateRules(namePath, value, rules, options, validateFirst, messageVariables) {\n  const name = namePath.join('.');\n\n  // Fill rule with context\n  const filledRules = rules.map((currentRule, ruleIndex) => {\n    const originValidatorFunc = currentRule.validator;\n    const cloneRule = {\n      ...currentRule,\n      ruleIndex\n    };\n\n    // Replace validator if needed\n    if (originValidatorFunc) {\n      cloneRule.validator = (rule, val, callback) => {\n        let hasPromise = false;\n\n        // Wrap callback only accept when promise not provided\n        const wrappedCallback = (...args) => {\n          // Wait a tick to make sure return type is a promise\n          Promise.resolve().then(() => {\n            warning(!hasPromise, 'Your validator function has already return a promise. `callback` will be ignored.');\n            if (!hasPromise) {\n              callback(...args);\n            }\n          });\n        };\n\n        // Get promise\n        const promise = originValidatorFunc(rule, val, wrappedCallback);\n        hasPromise = promise && typeof promise.then === 'function' && typeof promise.catch === 'function';\n\n        /**\n         * 1. Use promise as the first priority.\n         * 2. If promise not exist, use callback with warning instead\n         */\n        warning(hasPromise, '`callback` is deprecated. Please return a promise instead.');\n        if (hasPromise) {\n          promise.then(() => {\n            callback();\n          }).catch(err => {\n            callback(err || ' ');\n          });\n        }\n      };\n    }\n    return cloneRule;\n  }).sort(({\n    warningOnly: w1,\n    ruleIndex: i1\n  }, {\n    warningOnly: w2,\n    ruleIndex: i2\n  }) => {\n    if (!!w1 === !!w2) {\n      // Let keep origin order\n      return i1 - i2;\n    }\n    if (w1) {\n      return 1;\n    }\n    return -1;\n  });\n\n  // Do validate rules\n  let summaryPromise;\n  if (validateFirst === true) {\n    // >>>>> Validate by serialization\n    summaryPromise = new Promise(async (resolve, reject) => {\n      /* eslint-disable no-await-in-loop */\n      for (let i = 0; i < filledRules.length; i += 1) {\n        const rule = filledRules[i];\n        const errors = await validateRule(name, value, rule, options, messageVariables);\n        if (errors.length) {\n          reject([{\n            errors,\n            rule\n          }]);\n          return;\n        }\n      }\n      /* eslint-enable */\n\n      resolve([]);\n    });\n  } else {\n    // >>>>> Validate by parallel\n    const rulePromises = filledRules.map(rule => validateRule(name, value, rule, options, messageVariables).then(errors => ({\n      errors,\n      rule\n    })));\n    summaryPromise = (validateFirst ? finishOnFirstFailed(rulePromises) : finishOnAllFailed(rulePromises)).then(errors => {\n      // Always change to rejection for Field to catch\n      return Promise.reject(errors);\n    });\n  }\n\n  // Internal catch error to avoid console error log.\n  summaryPromise.catch(e => e);\n  return summaryPromise;\n}\nasync function finishOnAllFailed(rulePromises) {\n  return Promise.all(rulePromises).then(errorsList => {\n    const errors = [].concat(...errorsList);\n    return errors;\n  });\n}\nasync function finishOnFirstFailed(rulePromises) {\n  let count = 0;\n  return new Promise(resolve => {\n    rulePromises.forEach(promise => {\n      promise.then(ruleError => {\n        if (ruleError.errors.length) {\n          resolve([ruleError]);\n        }\n        count += 1;\n        if (count === rulePromises.length) {\n          resolve([]);\n        }\n      });\n    });\n  });\n}"],"names":[],"mappings":"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","ignoreList":[0],"debugId":null}},
    {"offset": {"line": 372, "column": 0}, "map": {"version":3,"sources":["file:///Users/best/Documents/admin-frontend-next/www/node_modules/%40rc-component/form/es/utils/valueUtil.js"],"sourcesContent":["import getValue from \"@rc-component/util/es/utils/get\";\nimport setValue from \"@rc-component/util/es/utils/set\";\nimport { toArray } from \"./typeUtil\";\nexport { getValue, setValue };\n\n/**\n * Convert name to internal supported format.\n * This function should keep since we still thinking if need support like `a.b.c` format.\n * 'a' => ['a']\n * 123 => [123]\n * ['a', 123] => ['a', 123]\n */\nexport function getNamePath(path) {\n  return toArray(path);\n}\n\n/**\n * Create a new store object that contains only the values referenced by\n * the provided list of name paths.\n */\nexport function cloneByNamePathList(store, namePathList) {\n  let newStore = {};\n  namePathList.forEach(namePath => {\n    const value = getValue(store, namePath);\n    newStore = setValue(newStore, namePath, value);\n  });\n  return newStore;\n}\n\n/**\n * Check if `namePathList` includes `namePath`.\n * @param namePathList A list of `InternalNamePath[]`\n * @param namePath Compare `InternalNamePath`\n * @param partialMatch True will make `[a, b]` match `[a, b, c]`\n */\nexport function containsNamePath(namePathList, namePath, partialMatch = false) {\n  return namePathList && namePathList.some(path => matchNamePath(namePath, path, partialMatch));\n}\n\n/**\n * Check if `namePath` is super set or equal of `subNamePath`.\n * @param namePath A list of `InternalNamePath[]`\n * @param subNamePath Compare `InternalNamePath`\n * @param partialMatch True will make `[a, b]` match `[a, b, c]`\n */\nexport function matchNamePath(namePath, subNamePath, partialMatch = false) {\n  if (!namePath || !subNamePath) {\n    return false;\n  }\n  if (!partialMatch && namePath.length !== subNamePath.length) {\n    return false;\n  }\n  return subNamePath.every((nameUnit, i) => namePath[i] === nameUnit);\n}\n\n// Like `shallowEqual`, but we not check the data which may cause re-render\n\nexport function isSimilar(source, target) {\n  if (source === target) {\n    return true;\n  }\n  if (!source && target || source && !target) {\n    return false;\n  }\n  if (!source || !target || typeof source !== 'object' || typeof target !== 'object') {\n    return false;\n  }\n  const sourceKeys = Object.keys(source);\n  const targetKeys = Object.keys(target);\n  const keys = new Set([...sourceKeys, ...targetKeys]);\n  return [...keys].every(key => {\n    const sourceValue = source[key];\n    const targetValue = target[key];\n    if (typeof sourceValue === 'function' && typeof targetValue === 'function') {\n      return true;\n    }\n    return sourceValue === targetValue;\n  });\n}\nexport function defaultGetValueFromEvent(valuePropName, ...args) {\n  const event = args[0];\n  if (event && event.target && typeof event.target === 'object' && valuePropName in event.target) {\n    return event.target[valuePropName];\n  }\n  return event;\n}\n\n/**\n * Moves an array item from one position in an array to another.\n *\n * Note: This is a pure function so a new array will be returned, instead\n * of altering the array argument.\n *\n * @param array         Array in which to move an item.         (required)\n * @param moveIndex     The index of the item to move.          (required)\n * @param toIndex       The index to move item at moveIndex to. (required)\n */\nexport function move(array, moveIndex, toIndex) {\n  const {\n    length\n  } = array;\n  if (moveIndex < 0 || moveIndex >= length || toIndex < 0 || toIndex >= length) {\n    return array;\n  }\n  const item = array[moveIndex];\n  const diff = moveIndex - toIndex;\n  if (diff > 0) {\n    // move left\n    return [...array.slice(0, toIndex), item, ...array.slice(toIndex, moveIndex), ...array.slice(moveIndex + 1, length)];\n  }\n  if (diff < 0) {\n    // move right\n    return [...array.slice(0, moveIndex), ...array.slice(moveIndex + 1, toIndex + 1), item, ...array.slice(toIndex + 1, length)];\n  }\n  return array;\n}"],"names":[],"mappings":";;;;;;;;;;;;;;;;AAAA;AACA;AACA;;;;;AAUO,SAAS,YAAY,IAAI;IAC9B,OAAO,IAAA,mOAAO,EAAC;AACjB;AAMO,SAAS,oBAAoB,KAAK,EAAE,YAAY;IACrD,IAAI,WAAW,CAAC;IAChB,aAAa,OAAO,CAAC,CAAA;QACnB,MAAM,QAAQ,IAAA,8NAAQ,EAAC,OAAO;QAC9B,WAAW,IAAA,8NAAQ,EAAC,UAAU,UAAU;IAC1C;IACA,OAAO;AACT;AAQO,SAAS,iBAAiB,YAAY,EAAE,QAAQ;QAAE,eAAA,iEAAe;IACtE,OAAO,gBAAgB,aAAa,IAAI,CAAC,CAAA,OAAQ,cAAc,UAAU,MAAM;AACjF;AAQO,SAAS,cAAc,QAAQ,EAAE,WAAW;QAAE,eAAA,iEAAe;IAClE,IAAI,CAAC,YAAY,CAAC,aAAa;QAC7B,OAAO;IACT;IACA,IAAI,CAAC,gBAAgB,SAAS,MAAM,KAAK,YAAY,MAAM,EAAE;QAC3D,OAAO;IACT;IACA,OAAO,YAAY,KAAK,CAAC,CAAC,UAAU,IAAM,QAAQ,CAAC,EAAE,KAAK;AAC5D;AAIO,SAAS,UAAU,MAAM,EAAE,MAAM;IACtC,IAAI,WAAW,QAAQ;QACrB,OAAO;IACT;IACA,IAAI,CAAC,UAAU,UAAU,UAAU,CAAC,QAAQ;QAC1C,OAAO;IACT;IACA,IAAI,CAAC,UAAU,CAAC,UAAU,OAAO,WAAW,YAAY,OAAO,WAAW,UAAU;QAClF,OAAO;IACT;IACA,MAAM,aAAa,OAAO,IAAI,CAAC;IAC/B,MAAM,aAAa,OAAO,IAAI,CAAC;IAC/B,MAAM,OAAO,IAAI,IAAI;WAAI;WAAe;KAAW;IACnD,OAAO;WAAI;KAAK,CAAC,KAAK,CAAC,CAAA;QACrB,MAAM,cAAc,MAAM,CAAC,IAAI;QAC/B,MAAM,cAAc,MAAM,CAAC,IAAI;QAC/B,IAAI,OAAO,gBAAgB,cAAc,OAAO,gBAAgB,YAAY;YAC1E,OAAO;QACT;QACA,OAAO,gBAAgB;IACzB;AACF;AACO,SAAS,yBAAyB,aAAa;IAAE,IAAA,IAAA,OAAA,UAAA,QAAA,AAAG,OAAH,UAAA,OAAA,IAAA,OAAA,QAAA,OAAA,GAAA,OAAA,MAAA;QAAG,KAAH,OAAA,KAAA,SAAA,CAAA,KAAO;;IAC7D,MAAM,QAAQ,IAAI,CAAC,EAAE;IACrB,IAAI,SAAS,MAAM,MAAM,IAAI,OAAO,MAAM,MAAM,KAAK,YAAY,iBAAiB,MAAM,MAAM,EAAE;QAC9F,OAAO,MAAM,MAAM,CAAC,cAAc;IACpC;IACA,OAAO;AACT;AAYO,SAAS,KAAK,KAAK,EAAE,SAAS,EAAE,OAAO;IAC5C,MAAM,EACJ,MAAM,EACP,GAAG;IACJ,IAAI,YAAY,KAAK,aAAa,UAAU,UAAU,KAAK,WAAW,QAAQ;QAC5E,OAAO;IACT;IACA,MAAM,OAAO,KAAK,CAAC,UAAU;IAC7B,MAAM,OAAO,YAAY;IACzB,IAAI,OAAO,GAAG;QACZ,YAAY;QACZ,OAAO;eAAI,MAAM,KAAK,CAAC,GAAG;YAAU;eAAS,MAAM,KAAK,CAAC,SAAS;eAAe,MAAM,KAAK,CAAC,YAAY,GAAG;SAAQ;IACtH;IACA,IAAI,OAAO,GAAG;QACZ,aAAa;QACb,OAAO;eAAI,MAAM,KAAK,CAAC,GAAG;eAAe,MAAM,KAAK,CAAC,YAAY,GAAG,UAAU;YAAI;eAAS,MAAM,KAAK,CAAC,UAAU,GAAG;SAAQ;IAC9H;IACA,OAAO;AACT","ignoreList":[0],"debugId":null}},
    {"offset": {"line": 488, "column": 0}, "map": {"version":3,"sources":["file:///Users/best/Documents/admin-frontend-next/www/node_modules/%40rc-component/form/es/Field.js"],"sourcesContent":["function _extends() { _extends = Object.assign ? Object.assign.bind() : function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; }; return _extends.apply(this, arguments); }\nimport toChildrenArray from \"@rc-component/util/es/Children/toArray\";\nimport isEqual from \"@rc-component/util/es/isEqual\";\nimport warning from \"@rc-component/util/es/warning\";\nimport * as React from 'react';\nimport FieldContext, { HOOK_MARK } from \"./FieldContext\";\nimport ListContext from \"./ListContext\";\nimport { toArray } from \"./utils/typeUtil\";\nimport { validateRules } from \"./utils/validateUtil\";\nimport { containsNamePath, defaultGetValueFromEvent, getNamePath, getValue } from \"./utils/valueUtil\";\nconst EMPTY_ERRORS = [];\nconst EMPTY_WARNINGS = [];\nfunction requireUpdate(shouldUpdate, prev, next, prevValue, nextValue, info) {\n  if (typeof shouldUpdate === 'function') {\n    return shouldUpdate(prev, next, 'source' in info ? {\n      source: info.source\n    } : {});\n  }\n  return prevValue !== nextValue;\n}\n\n// eslint-disable-next-line @typescript-eslint/consistent-indexed-object-style\n\n// We use Class instead of Hooks here since it will cost much code by using Hooks.\nclass Field extends React.Component {\n  static contextType = FieldContext;\n  state = {\n    resetCount: 0\n  };\n  cancelRegisterFunc = null;\n  mounted = false;\n\n  /**\n   * Follow state should not management in State since it will async update by React.\n   * This makes first render of form can not get correct state value.\n   */\n  touched = false;\n\n  /**\n   * Mark when touched & validated. Currently only used for `dependencies`.\n   * Note that we do not think field with `initialValue` is dirty\n   * but this will be by `isFieldDirty` func.\n   */\n  dirty = false;\n  validatePromise;\n  prevValidating;\n  errors = EMPTY_ERRORS;\n  warnings = EMPTY_WARNINGS;\n\n  // ============================== Subscriptions ==============================\n  constructor(props) {\n    super(props);\n\n    // Register on init\n    if (props.fieldContext) {\n      const {\n        getInternalHooks\n      } = props.fieldContext;\n      const {\n        initEntityValue\n      } = getInternalHooks(HOOK_MARK);\n      initEntityValue(this);\n    }\n  }\n  componentDidMount() {\n    const {\n      shouldUpdate,\n      fieldContext\n    } = this.props;\n    this.mounted = true;\n\n    // Register on init\n    if (fieldContext) {\n      const {\n        getInternalHooks\n      } = fieldContext;\n      const {\n        registerField\n      } = getInternalHooks(HOOK_MARK);\n      this.cancelRegisterFunc = registerField(this);\n    }\n\n    // One more render for component in case fields not ready\n    if (shouldUpdate === true) {\n      this.reRender();\n    }\n  }\n  componentWillUnmount() {\n    this.cancelRegister();\n    this.triggerMetaEvent(true);\n    this.mounted = false;\n  }\n  cancelRegister = () => {\n    const {\n      preserve,\n      isListField,\n      name\n    } = this.props;\n    if (this.cancelRegisterFunc) {\n      this.cancelRegisterFunc(isListField, preserve, getNamePath(name));\n    }\n    this.cancelRegisterFunc = null;\n  };\n\n  // ================================== Utils ==================================\n  getNamePath = () => {\n    const {\n      name,\n      fieldContext\n    } = this.props;\n    const {\n      prefixName = []\n    } = fieldContext;\n    return name !== undefined ? [...prefixName, ...name] : [];\n  };\n  getRules = () => {\n    const {\n      rules = [],\n      fieldContext\n    } = this.props;\n    return rules.map(rule => {\n      if (typeof rule === 'function') {\n        return rule(fieldContext);\n      }\n      return rule;\n    });\n  };\n  reRender() {\n    if (!this.mounted) return;\n    this.forceUpdate();\n  }\n  refresh = () => {\n    if (!this.mounted) return;\n\n    /**\n     * Clean up current node.\n     */\n    this.setState(({\n      resetCount\n    }) => ({\n      resetCount: resetCount + 1\n    }));\n  };\n\n  // Event should only trigger when meta changed\n  metaCache = null;\n  triggerMetaEvent = destroy => {\n    const {\n      onMetaChange\n    } = this.props;\n    if (onMetaChange) {\n      const meta = {\n        ...this.getMeta(),\n        destroy\n      };\n      if (!isEqual(this.metaCache, meta)) {\n        onMetaChange(meta);\n      }\n      this.metaCache = meta;\n    } else {\n      this.metaCache = null;\n    }\n  };\n\n  // ========================= Field Entity Interfaces =========================\n  // Trigger by store update. Check if need update the component\n  onStoreChange = (prevStore, namePathList, info) => {\n    const {\n      shouldUpdate,\n      dependencies = [],\n      onReset\n    } = this.props;\n    const {\n      store\n    } = info;\n    const namePath = this.getNamePath();\n    const prevValue = this.getValue(prevStore);\n    const curValue = this.getValue(store);\n    const namePathMatch = namePathList && containsNamePath(namePathList, namePath);\n\n    // `setFieldsValue` is a quick access to update related status\n    if (info.type === 'valueUpdate' && info.source === 'external' && !isEqual(prevValue, curValue)) {\n      this.touched = true;\n      this.dirty = true;\n      this.validatePromise = null;\n      this.errors = EMPTY_ERRORS;\n      this.warnings = EMPTY_WARNINGS;\n      this.triggerMetaEvent();\n    }\n    switch (info.type) {\n      case 'reset':\n        if (!namePathList || namePathMatch) {\n          // Clean up state\n          this.touched = false;\n          this.dirty = false;\n          this.validatePromise = undefined;\n          this.errors = EMPTY_ERRORS;\n          this.warnings = EMPTY_WARNINGS;\n          this.triggerMetaEvent();\n          onReset?.();\n          this.refresh();\n          return;\n        }\n        break;\n\n      /**\n       * In case field with `preserve = false` nest deps like:\n       * - A = 1 => show B\n       * - B = 1 => show C\n       * - Reset A, need clean B, C\n       */\n      case 'remove':\n        {\n          if (shouldUpdate && requireUpdate(shouldUpdate, prevStore, store, prevValue, curValue, info)) {\n            this.reRender();\n            return;\n          }\n          break;\n        }\n      case 'setField':\n        {\n          const {\n            data\n          } = info;\n          if (namePathMatch) {\n            if ('touched' in data) {\n              this.touched = data.touched;\n            }\n            if ('validating' in data && !('originRCField' in data)) {\n              this.validatePromise = data.validating ? Promise.resolve([]) : null;\n            }\n            if ('errors' in data) {\n              this.errors = data.errors || EMPTY_ERRORS;\n            }\n            if ('warnings' in data) {\n              this.warnings = data.warnings || EMPTY_WARNINGS;\n            }\n            this.dirty = true;\n            this.triggerMetaEvent();\n            this.reRender();\n            return;\n          } else if ('value' in data && containsNamePath(namePathList, namePath, true)) {\n            // Contains path with value should also check\n            this.reRender();\n            return;\n          }\n\n          // Handle update by `setField` with `shouldUpdate`\n          if (shouldUpdate && !namePath.length && requireUpdate(shouldUpdate, prevStore, store, prevValue, curValue, info)) {\n            this.reRender();\n            return;\n          }\n          break;\n        }\n      case 'dependenciesUpdate':\n        {\n          /**\n           * Trigger when marked `dependencies` updated. Related fields will all update\n           */\n          const dependencyList = dependencies.map(getNamePath);\n          // No need for `namePathMath` check and `shouldUpdate` check, since `valueUpdate` will be\n          // emitted earlier and they will work there\n          // If set it may cause unnecessary twice rerendering\n          if (dependencyList.some(dependency => containsNamePath(info.relatedFields, dependency))) {\n            this.reRender();\n            return;\n          }\n          break;\n        }\n      default:\n        // 1. If `namePath` exists in `namePathList`, means it's related value and should update\n        //      For example <List name=\"list\"><Field name={['list', 0]}></List>\n        //      If `namePathList` is [['list']] (List value update), Field should be updated\n        //      If `namePathList` is [['list', 0]] (Field value update), List shouldn't be updated\n        // 2.\n        //   2.1 If `dependencies` is set, `name` is not set and `shouldUpdate` is not set,\n        //       don't use `shouldUpdate`. `dependencies` is view as a shortcut if `shouldUpdate`\n        //       is not provided\n        //   2.2 If `shouldUpdate` provided, use customize logic to update the field\n        //       else to check if value changed\n        if (namePathMatch || (!dependencies.length || namePath.length || shouldUpdate) && requireUpdate(shouldUpdate, prevStore, store, prevValue, curValue, info)) {\n          this.reRender();\n          return;\n        }\n        break;\n    }\n    if (shouldUpdate === true) {\n      this.reRender();\n    }\n  };\n  validateRules = options => {\n    // We should fixed namePath & value to avoid developer change then by form function\n    const namePath = this.getNamePath();\n    const currentValue = this.getValue();\n    const {\n      triggerName,\n      validateOnly = false\n    } = options || {};\n\n    // Force change to async to avoid rule OOD under renderProps field\n    const rootPromise = Promise.resolve().then(async () => {\n      if (!this.mounted) {\n        return [];\n      }\n      const {\n        validateFirst = false,\n        messageVariables,\n        validateDebounce\n      } = this.props;\n\n      // Start validate\n      let filteredRules = this.getRules();\n      if (triggerName) {\n        filteredRules = filteredRules.filter(rule => rule).filter(rule => {\n          const {\n            validateTrigger\n          } = rule;\n          if (!validateTrigger) {\n            return true;\n          }\n          const triggerList = toArray(validateTrigger);\n          return triggerList.includes(triggerName);\n        });\n      }\n\n      // Wait for debounce. Skip if no `triggerName` since its from `validateFields / submit`\n      if (validateDebounce && triggerName) {\n        await new Promise(resolve => {\n          setTimeout(resolve, validateDebounce);\n        });\n\n        // Skip since out of date\n        if (this.validatePromise !== rootPromise) {\n          return [];\n        }\n      }\n      const promise = validateRules(namePath, currentValue, filteredRules, options, validateFirst, messageVariables);\n      promise.catch(e => e).then((ruleErrors = EMPTY_ERRORS) => {\n        if (this.validatePromise === rootPromise) {\n          this.validatePromise = null;\n\n          // Get errors & warnings\n          const nextErrors = [];\n          const nextWarnings = [];\n          ruleErrors.forEach?.(({\n            rule: {\n              warningOnly\n            },\n            errors = EMPTY_ERRORS\n          }) => {\n            if (warningOnly) {\n              nextWarnings.push(...errors);\n            } else {\n              nextErrors.push(...errors);\n            }\n          });\n          this.errors = nextErrors;\n          this.warnings = nextWarnings;\n          this.triggerMetaEvent();\n          this.reRender();\n        }\n      });\n      return promise;\n    });\n    if (validateOnly) {\n      return rootPromise;\n    }\n    this.validatePromise = rootPromise;\n    this.dirty = true;\n    this.errors = EMPTY_ERRORS;\n    this.warnings = EMPTY_WARNINGS;\n    this.triggerMetaEvent();\n\n    // Force trigger re-render since we need sync renderProps with new meta\n    this.reRender();\n    return rootPromise;\n  };\n  isFieldValidating = () => !!this.validatePromise;\n  isFieldTouched = () => this.touched;\n  isFieldDirty = () => {\n    // Touched or validate or has initialValue\n    if (this.dirty || this.props.initialValue !== undefined) {\n      return true;\n    }\n\n    // Form set initialValue\n    const {\n      fieldContext\n    } = this.props;\n    const {\n      getInitialValue\n    } = fieldContext.getInternalHooks(HOOK_MARK);\n    if (getInitialValue(this.getNamePath()) !== undefined) {\n      return true;\n    }\n    return false;\n  };\n  getErrors = () => this.errors;\n  getWarnings = () => this.warnings;\n  isListField = () => this.props.isListField;\n  isList = () => this.props.isList;\n  isPreserve = () => this.props.preserve;\n\n  // ============================= Child Component =============================\n  getMeta = () => {\n    // Make error & validating in cache to save perf\n    this.prevValidating = this.isFieldValidating();\n    const meta = {\n      touched: this.isFieldTouched(),\n      validating: this.prevValidating,\n      errors: this.errors,\n      warnings: this.warnings,\n      name: this.getNamePath(),\n      validated: this.validatePromise === null\n    };\n    return meta;\n  };\n\n  // Only return validate child node. If invalidate, will do nothing about field.\n  getOnlyChild = children => {\n    // Support render props\n    if (typeof children === 'function') {\n      const meta = this.getMeta();\n      return {\n        ...this.getOnlyChild(children(this.getControlled(), meta, this.props.fieldContext)),\n        isFunction: true\n      };\n    }\n\n    // Filed element only\n    const childList = toChildrenArray(children);\n    if (childList.length !== 1 || ! /*#__PURE__*/React.isValidElement(childList[0])) {\n      return {\n        child: childList,\n        isFunction: false\n      };\n    }\n    return {\n      child: childList[0],\n      isFunction: false\n    };\n  };\n\n  // ============================== Field Control ==============================\n  getValue = store => {\n    const {\n      getFieldsValue\n    } = this.props.fieldContext;\n    const namePath = this.getNamePath();\n    return getValue(store || getFieldsValue(true), namePath);\n  };\n  getControlled = (childProps = {}) => {\n    const {\n      name,\n      trigger = 'onChange',\n      validateTrigger,\n      getValueFromEvent,\n      normalize,\n      valuePropName = 'value',\n      getValueProps,\n      fieldContext\n    } = this.props;\n    const mergedValidateTrigger = validateTrigger !== undefined ? validateTrigger : fieldContext.validateTrigger;\n    const namePath = this.getNamePath();\n    const {\n      getInternalHooks,\n      getFieldsValue\n    } = fieldContext;\n    const {\n      dispatch\n    } = getInternalHooks(HOOK_MARK);\n    const value = this.getValue();\n    const mergedGetValueProps = getValueProps || (val => ({\n      [valuePropName]: val\n    }));\n    const originTriggerFunc = childProps[trigger];\n    const valueProps = name !== undefined ? mergedGetValueProps(value) : {};\n\n    // warning when prop value is function\n    if (process.env.NODE_ENV !== 'production' && valueProps) {\n      Object.keys(valueProps).forEach(key => {\n        warning(typeof valueProps[key] !== 'function', `It's not recommended to generate dynamic function prop by \\`getValueProps\\`. Please pass it to child component directly (prop: ${key})`);\n      });\n    }\n    const control = {\n      ...childProps,\n      ...valueProps\n    };\n\n    // Add trigger\n    control[trigger] = (...args) => {\n      // Mark as touched\n      this.touched = true;\n      this.dirty = true;\n      this.triggerMetaEvent();\n      let newValue;\n      if (getValueFromEvent) {\n        newValue = getValueFromEvent(...args);\n      } else {\n        newValue = defaultGetValueFromEvent(valuePropName, ...args);\n      }\n      if (normalize) {\n        newValue = normalize(newValue, value, getFieldsValue(true));\n      }\n      if (newValue !== value) {\n        dispatch({\n          type: 'updateValue',\n          namePath,\n          value: newValue\n        });\n      }\n      if (originTriggerFunc) {\n        originTriggerFunc(...args);\n      }\n    };\n\n    // Add validateTrigger\n    const validateTriggerList = toArray(mergedValidateTrigger || []);\n    validateTriggerList.forEach(triggerName => {\n      // Wrap additional function of component, so that we can get latest value from store\n      const originTrigger = control[triggerName];\n      control[triggerName] = (...args) => {\n        if (originTrigger) {\n          originTrigger(...args);\n        }\n\n        // Always use latest rules\n        const {\n          rules\n        } = this.props;\n        if (rules && rules.length) {\n          // We dispatch validate to root,\n          // since it will update related data with other field with same name\n          dispatch({\n            type: 'validateField',\n            namePath,\n            triggerName\n          });\n        }\n      };\n    });\n    return control;\n  };\n  render() {\n    const {\n      resetCount\n    } = this.state;\n    const {\n      children\n    } = this.props;\n    const {\n      child,\n      isFunction\n    } = this.getOnlyChild(children);\n\n    // Not need to `cloneElement` since user can handle this in render function self\n    let returnChildNode;\n    if (isFunction) {\n      returnChildNode = child;\n    } else if ( /*#__PURE__*/React.isValidElement(child)) {\n      returnChildNode = /*#__PURE__*/React.cloneElement(child, this.getControlled(child.props));\n    } else {\n      warning(!child, '`children` of Field is not validate ReactElement.');\n      returnChildNode = child;\n    }\n    return /*#__PURE__*/React.createElement(React.Fragment, {\n      key: resetCount\n    }, returnChildNode);\n  }\n}\nfunction WrapperField({\n  name,\n  ...restProps\n}) {\n  const fieldContext = React.useContext(FieldContext);\n  const listContext = React.useContext(ListContext);\n  const namePath = name !== undefined ? getNamePath(name) : undefined;\n  const isMergedListField = restProps.isListField ?? !!listContext;\n  let key = 'keep';\n  if (!isMergedListField) {\n    key = `_${(namePath || []).join('_')}`;\n  }\n\n  // Warning if it's a directly list field.\n  // We can still support multiple level field preserve.\n  if (process.env.NODE_ENV !== 'production' && restProps.preserve === false && isMergedListField && namePath.length <= 1) {\n    warning(false, '`preserve` should not apply on Form.List fields.');\n  }\n  return /*#__PURE__*/React.createElement(Field, _extends({\n    key: key,\n    name: namePath,\n    isListField: isMergedListField\n  }, restProps, {\n    fieldContext: fieldContext\n  }));\n}\nexport default WrapperField;"],"names":[],"mappings":"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","ignoreList":[0],"debugId":null}},
    {"offset": {"line": 985, "column": 0}, "map": {"version":3,"sources":["file:///Users/best/Documents/admin-frontend-next/www/node_modules/%40rc-component/form/es/List.js"],"sourcesContent":["import * as React from 'react';\nimport warning from \"@rc-component/util/es/warning\";\nimport FieldContext from \"./FieldContext\";\nimport Field from \"./Field\";\nimport { move, getNamePath } from \"./utils/valueUtil\";\nimport ListContext from \"./ListContext\";\nfunction List({\n  name,\n  initialValue,\n  children,\n  rules,\n  validateTrigger,\n  isListField\n}) {\n  const context = React.useContext(FieldContext);\n  const wrapperListContext = React.useContext(ListContext);\n  const keyRef = React.useRef({\n    keys: [],\n    id: 0\n  });\n  const keyManager = keyRef.current;\n  const prefixName = React.useMemo(() => {\n    const parentPrefixName = getNamePath(context.prefixName) || [];\n    return [...parentPrefixName, ...getNamePath(name)];\n  }, [context.prefixName, name]);\n  const fieldContext = React.useMemo(() => ({\n    ...context,\n    prefixName\n  }), [context, prefixName]);\n\n  // List context\n  const listContext = React.useMemo(() => ({\n    getKey: namePath => {\n      const len = prefixName.length;\n      const pathName = namePath[len];\n      return [keyManager.keys[pathName], namePath.slice(len + 1)];\n    }\n  }), [keyManager, prefixName]);\n\n  // User should not pass `children` as other type.\n  if (typeof children !== 'function') {\n    warning(false, 'Form.List only accepts function as children.');\n    return null;\n  }\n  const shouldUpdate = (prevValue, nextValue, {\n    source\n  }) => {\n    if (source === 'internal') {\n      return false;\n    }\n    return prevValue !== nextValue;\n  };\n  return /*#__PURE__*/React.createElement(ListContext.Provider, {\n    value: listContext\n  }, /*#__PURE__*/React.createElement(FieldContext.Provider, {\n    value: fieldContext\n  }, /*#__PURE__*/React.createElement(Field, {\n    name: [],\n    shouldUpdate: shouldUpdate,\n    rules: rules,\n    validateTrigger: validateTrigger,\n    initialValue: initialValue,\n    isList: true,\n    isListField: isListField ?? !!wrapperListContext\n  }, ({\n    value = [],\n    onChange\n  }, meta) => {\n    const {\n      getFieldValue\n    } = context;\n    const getNewValue = () => {\n      const values = getFieldValue(prefixName || []);\n      return values || [];\n    };\n    /**\n     * Always get latest value in case user update fields by `form` api.\n     */\n    const operations = {\n      add: (defaultValue, index) => {\n        // Mapping keys\n        const newValue = getNewValue();\n        if (index >= 0 && index <= newValue.length) {\n          keyManager.keys = [...keyManager.keys.slice(0, index), keyManager.id, ...keyManager.keys.slice(index)];\n          onChange([...newValue.slice(0, index), defaultValue, ...newValue.slice(index)]);\n        } else {\n          if (process.env.NODE_ENV !== 'production' && (index < 0 || index > newValue.length)) {\n            warning(false, 'The second parameter of the add function should be a valid positive number.');\n          }\n          keyManager.keys = [...keyManager.keys, keyManager.id];\n          onChange([...newValue, defaultValue]);\n        }\n        keyManager.id += 1;\n      },\n      remove: index => {\n        const newValue = getNewValue();\n        const indexSet = new Set(Array.isArray(index) ? index : [index]);\n        if (indexSet.size <= 0) {\n          return;\n        }\n        keyManager.keys = keyManager.keys.filter((_, keysIndex) => !indexSet.has(keysIndex));\n\n        // Trigger store change\n        onChange(newValue.filter((_, valueIndex) => !indexSet.has(valueIndex)));\n      },\n      move(from, to) {\n        if (from === to) {\n          return;\n        }\n        const newValue = getNewValue();\n\n        // Do not handle out of range\n        if (from < 0 || from >= newValue.length || to < 0 || to >= newValue.length) {\n          return;\n        }\n        keyManager.keys = move(keyManager.keys, from, to);\n\n        // Trigger store change\n        onChange(move(newValue, from, to));\n      }\n    };\n    let listValue = value || [];\n    if (!Array.isArray(listValue)) {\n      listValue = [];\n      if (process.env.NODE_ENV !== 'production') {\n        warning(false, `Current value of '${prefixName.join(' > ')}' is not an array type.`);\n      }\n    }\n    return children(listValue.map((__, index) => {\n      let key = keyManager.keys[index];\n      if (key === undefined) {\n        keyManager.keys[index] = keyManager.id;\n        key = keyManager.keys[index];\n        keyManager.id += 1;\n      }\n      return {\n        name: index,\n        key,\n        isListField: true\n      };\n    }), operations, meta);\n  })));\n}\nexport default List;"],"names":[],"mappings":"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","ignoreList":[0],"debugId":null}},
    {"offset": {"line": 1166, "column": 0}, "map": {"version":3,"sources":["file:///Users/best/Documents/admin-frontend-next/www/node_modules/%40rc-component/form/es/utils/asyncUtil.js"],"sourcesContent":["export function allPromiseFinish(promiseList) {\n  let hasError = false;\n  let count = promiseList.length;\n  const results = [];\n  if (!promiseList.length) {\n    return Promise.resolve([]);\n  }\n  return new Promise((resolve, reject) => {\n    promiseList.forEach((promise, index) => {\n      promise.catch(e => {\n        hasError = true;\n        return e;\n      }).then(result => {\n        count -= 1;\n        results[index] = result;\n        if (count > 0) {\n          return;\n        }\n        if (hasError) {\n          reject(results);\n        }\n        resolve(results);\n      });\n    });\n  });\n}"],"names":[],"mappings":";;;;AAAO,SAAS,iBAAiB,WAAW;IAC1C,IAAI,WAAW;IACf,IAAI,QAAQ,YAAY,MAAM;IAC9B,MAAM,UAAU,EAAE;IAClB,IAAI,CAAC,YAAY,MAAM,EAAE;QACvB,OAAO,QAAQ,OAAO,CAAC,EAAE;IAC3B;IACA,OAAO,IAAI,QAAQ,CAAC,SAAS;QAC3B,YAAY,OAAO,CAAC,CAAC,SAAS;YAC5B,QAAQ,KAAK,CAAC,CAAA;gBACZ,WAAW;gBACX,OAAO;YACT,GAAG,IAAI,CAAC,CAAA;gBACN,SAAS;gBACT,OAAO,CAAC,MAAM,GAAG;gBACjB,IAAI,QAAQ,GAAG;oBACb;gBACF;gBACA,IAAI,UAAU;oBACZ,OAAO;gBACT;gBACA,QAAQ;YACV;QACF;IACF;AACF","ignoreList":[0],"debugId":null}},
    {"offset": {"line": 1200, "column": 0}, "map": {"version":3,"sources":["file:///Users/best/Documents/admin-frontend-next/www/node_modules/%40rc-component/form/es/utils/NameMap.js"],"sourcesContent":["const SPLIT = '__@field_split__';\n\n/**\n * Convert name path into string to fast the fetch speed of Map.\n */\nfunction normalize(namePath) {\n  return namePath.map(cell => `${typeof cell}:${cell}`)\n  // Magic split\n  .join(SPLIT);\n}\n\n/**\n * NameMap like a `Map` but accepts `string[]` as key.\n */\nclass NameMap {\n  kvs = new Map();\n  set(key, value) {\n    this.kvs.set(normalize(key), value);\n  }\n  get(key) {\n    return this.kvs.get(normalize(key));\n  }\n  update(key, updater) {\n    const origin = this.get(key);\n    const next = updater(origin);\n    if (!next) {\n      this.delete(key);\n    } else {\n      this.set(key, next);\n    }\n  }\n  delete(key) {\n    this.kvs.delete(normalize(key));\n  }\n\n  // Since we only use this in test, let simply realize this\n  map(callback) {\n    return [...this.kvs.entries()].map(([key, value]) => {\n      const cells = key.split(SPLIT);\n      return callback({\n        key: cells.map(cell => {\n          const [, type, unit] = cell.match(/^([^:]*):(.*)$/);\n          return type === 'number' ? Number(unit) : unit;\n        }),\n        value\n      });\n    });\n  }\n  toJSON() {\n    const json = {};\n    this.map(({\n      key,\n      value\n    }) => {\n      json[key.join('.')] = value;\n      return null;\n    });\n    return json;\n  }\n}\nexport default NameMap;"],"names":[],"mappings":";;;;;;AAAA,MAAM,QAAQ;AAEd;;CAEC,GACD,SAAS,UAAU,QAAQ;IACzB,OAAO,SAAS,GAAG,CAAC,CAAA,OAAQ,AAAC,GAAiB,OAAf,OAAO,MAAK,KAAQ,OAAL,MAC9C,cAAc;KACb,IAAI,CAAC;AACR;AAEA;;CAEC,GACD,MAAM;IAEJ,IAAI,GAAG,EAAE,KAAK,EAAE;QACd,IAAI,CAAC,GAAG,CAAC,GAAG,CAAC,UAAU,MAAM;IAC/B;IACA,IAAI,GAAG,EAAE;QACP,OAAO,IAAI,CAAC,GAAG,CAAC,GAAG,CAAC,UAAU;IAChC;IACA,OAAO,GAAG,EAAE,OAAO,EAAE;QACnB,MAAM,SAAS,IAAI,CAAC,GAAG,CAAC;QACxB,MAAM,OAAO,QAAQ;QACrB,IAAI,CAAC,MAAM;YACT,IAAI,CAAC,MAAM,CAAC;QACd,OAAO;YACL,IAAI,CAAC,GAAG,CAAC,KAAK;QAChB;IACF;IACA,OAAO,GAAG,EAAE;QACV,IAAI,CAAC,GAAG,CAAC,MAAM,CAAC,UAAU;IAC5B;IAEA,0DAA0D;IAC1D,IAAI,QAAQ,EAAE;QACZ,OAAO;eAAI,IAAI,CAAC,GAAG,CAAC,OAAO;SAAG,CAAC,GAAG,CAAC;gBAAC,CAAC,KAAK,MAAM;YAC9C,MAAM,QAAQ,IAAI,KAAK,CAAC;YACxB,OAAO,SAAS;gBACd,KAAK,MAAM,GAAG,CAAC,CAAA;oBACb,MAAM,GAAG,MAAM,KAAK,GAAG,KAAK,KAAK,CAAC;oBAClC,OAAO,SAAS,WAAW,OAAO,QAAQ;gBAC5C;gBACA;YACF;QACF;IACF;IACA,SAAS;QACP,MAAM,OAAO,CAAC;QACd,IAAI,CAAC,GAAG,CAAC;gBAAC,EACR,GAAG,EACH,KAAK,EACN;YACC,IAAI,CAAC,IAAI,IAAI,CAAC,KAAK,GAAG;YACtB,OAAO;QACT;QACA,OAAO;IACT;;QA3CA,gOAAA,OAAM,IAAI;;AA4CZ;uCACe","ignoreList":[0],"debugId":null}},
    {"offset": {"line": 1268, "column": 0}, "map": {"version":3,"sources":["file:///Users/best/Documents/admin-frontend-next/www/node_modules/%40rc-component/form/es/useForm.js"],"sourcesContent":["import { merge } from \"@rc-component/util/es/utils/set\";\nimport warning from \"@rc-component/util/es/warning\";\nimport * as React from 'react';\nimport { HOOK_MARK } from \"./FieldContext\";\nimport { allPromiseFinish } from \"./utils/asyncUtil\";\nimport { defaultValidateMessages } from \"./utils/messages\";\nimport NameMap from \"./utils/NameMap\";\nimport { cloneByNamePathList, containsNamePath, getNamePath, getValue, matchNamePath, setValue } from \"./utils/valueUtil\";\nexport class FormStore {\n  formHooked = false;\n  forceRootUpdate;\n  subscribable = true;\n  store = {};\n  fieldEntities = [];\n  initialValues = {};\n  callbacks = {};\n  validateMessages = null;\n  preserve = null;\n  lastValidatePromise = null;\n  constructor(forceRootUpdate) {\n    this.forceRootUpdate = forceRootUpdate;\n  }\n  getForm = () => ({\n    getFieldValue: this.getFieldValue,\n    getFieldsValue: this.getFieldsValue,\n    getFieldError: this.getFieldError,\n    getFieldWarning: this.getFieldWarning,\n    getFieldsError: this.getFieldsError,\n    isFieldsTouched: this.isFieldsTouched,\n    isFieldTouched: this.isFieldTouched,\n    isFieldValidating: this.isFieldValidating,\n    isFieldsValidating: this.isFieldsValidating,\n    resetFields: this.resetFields,\n    setFields: this.setFields,\n    setFieldValue: this.setFieldValue,\n    setFieldsValue: this.setFieldsValue,\n    validateFields: this.validateFields,\n    submit: this.submit,\n    _init: true,\n    getInternalHooks: this.getInternalHooks\n  });\n\n  // ======================== Internal Hooks ========================\n  getInternalHooks = key => {\n    if (key === HOOK_MARK) {\n      this.formHooked = true;\n      return {\n        dispatch: this.dispatch,\n        initEntityValue: this.initEntityValue,\n        registerField: this.registerField,\n        useSubscribe: this.useSubscribe,\n        setInitialValues: this.setInitialValues,\n        destroyForm: this.destroyForm,\n        setCallbacks: this.setCallbacks,\n        setValidateMessages: this.setValidateMessages,\n        getFields: this.getFields,\n        setPreserve: this.setPreserve,\n        getInitialValue: this.getInitialValue,\n        registerWatch: this.registerWatch,\n        setBatchUpdate: this.setBatchUpdate\n      };\n    }\n    warning(false, '`getInternalHooks` is internal usage. Should not call directly.');\n    return null;\n  };\n  useSubscribe = subscribable => {\n    this.subscribable = subscribable;\n  };\n\n  /**\n   * Record prev Form unmount fieldEntities which config preserve false.\n   * This need to be refill with initialValues instead of store value.\n   */\n  prevWithoutPreserves = null;\n\n  /**\n   * First time `setInitialValues` should update store with initial value\n   */\n  setInitialValues = (initialValues, init) => {\n    this.initialValues = initialValues || {};\n    if (init) {\n      let nextStore = merge(initialValues, this.store);\n\n      // We will take consider prev form unmount fields.\n      // When the field is not `preserve`, we need fill this with initialValues instead of store.\n      // eslint-disable-next-line array-callback-return\n      this.prevWithoutPreserves?.map(({\n        key: namePath\n      }) => {\n        nextStore = setValue(nextStore, namePath, getValue(initialValues, namePath));\n      });\n      this.prevWithoutPreserves = null;\n      this.updateStore(nextStore);\n    }\n  };\n  destroyForm = clearOnDestroy => {\n    if (clearOnDestroy) {\n      // destroy form reset store\n      this.updateStore({});\n    } else {\n      // Fill preserve fields\n      const prevWithoutPreserves = new NameMap();\n      this.getFieldEntities(true).forEach(entity => {\n        if (!this.isMergedPreserve(entity.isPreserve())) {\n          prevWithoutPreserves.set(entity.getNamePath(), true);\n        }\n      });\n      this.prevWithoutPreserves = prevWithoutPreserves;\n    }\n  };\n  getInitialValue = namePath => {\n    const initValue = getValue(this.initialValues, namePath);\n\n    // Not cloneDeep when without `namePath`\n    return namePath.length ? merge(initValue) : initValue;\n  };\n  setCallbacks = callbacks => {\n    this.callbacks = callbacks;\n  };\n  setValidateMessages = validateMessages => {\n    this.validateMessages = validateMessages;\n  };\n  setPreserve = preserve => {\n    this.preserve = preserve;\n  };\n\n  // ============================= Watch ============================\n  watchList = [];\n  registerWatch = callback => {\n    this.watchList.push(callback);\n    return () => {\n      this.watchList = this.watchList.filter(fn => fn !== callback);\n    };\n  };\n  notifyWatch = (namePath = []) => {\n    // No need to cost perf when nothing need to watch\n    if (this.watchList.length) {\n      const values = this.getFieldsValue();\n      const allValues = this.getFieldsValue(true);\n      this.watchList.forEach(callback => {\n        callback(values, allValues, namePath);\n      });\n    }\n  };\n  notifyWatchNamePathList = [];\n  batchNotifyWatch = namePath => {\n    this.notifyWatchNamePathList.push(namePath);\n    this.batch('notifyWatch', () => {\n      this.notifyWatch(this.notifyWatchNamePathList);\n      this.notifyWatchNamePathList = [];\n    });\n  };\n\n  // ============================= Batch ============================\n  batchUpdate;\n  setBatchUpdate = batchUpdate => {\n    this.batchUpdate = batchUpdate;\n  };\n\n  // Batch call the task, only last will be called\n  batch = (key, callback) => {\n    this.batchUpdate(key, callback);\n  };\n\n  // ========================== Dev Warning =========================\n  timeoutId = null;\n  warningUnhooked = () => {\n    if (process.env.NODE_ENV !== 'production' && !this.timeoutId && typeof window !== 'undefined') {\n      this.timeoutId = setTimeout(() => {\n        this.timeoutId = null;\n        if (!this.formHooked) {\n          warning(false, 'Instance created by `useForm` is not connected to any Form element. Forget to pass `form` prop?');\n        }\n      });\n    }\n  };\n\n  // ============================ Store =============================\n  updateStore = nextStore => {\n    this.store = nextStore;\n  };\n\n  // ============================ Fields ============================\n  /**\n   * Get registered field entities.\n   * @param pure Only return field which has a `name`. Default: false\n   */\n  getFieldEntities = (pure = false) => {\n    if (!pure) {\n      return this.fieldEntities;\n    }\n    return this.fieldEntities.filter(field => field.getNamePath().length);\n  };\n  getFieldsMap = (pure = false) => {\n    const cache = new NameMap();\n    this.getFieldEntities(pure).forEach(field => {\n      const namePath = field.getNamePath();\n      cache.set(namePath, field);\n    });\n    return cache;\n  };\n  getFieldEntitiesForNamePathList = nameList => {\n    if (!nameList) {\n      return this.getFieldEntities(true);\n    }\n    const cache = this.getFieldsMap(true);\n    return nameList.map(name => {\n      const namePath = getNamePath(name);\n      return cache.get(namePath) || {\n        INVALIDATE_NAME_PATH: getNamePath(name)\n      };\n    });\n  };\n  getFieldsValue = (nameList, filterFunc) => {\n    this.warningUnhooked();\n\n    // Fill args\n    let mergedNameList;\n    let mergedFilterFunc;\n    if (nameList === true || Array.isArray(nameList)) {\n      mergedNameList = nameList;\n      mergedFilterFunc = filterFunc;\n    } else if (nameList && typeof nameList === 'object') {\n      mergedFilterFunc = nameList.filter;\n    }\n    if (mergedNameList === true && !mergedFilterFunc) {\n      return this.store;\n    }\n    const fieldEntities = this.getFieldEntitiesForNamePathList(Array.isArray(mergedNameList) ? mergedNameList : null);\n    const filteredNameList = [];\n    const listNamePaths = [];\n    fieldEntities.forEach(entity => {\n      const namePath = entity.INVALIDATE_NAME_PATH || entity.getNamePath();\n\n      // Ignore when it's a list item and not specific the namePath,\n      // since parent field is already take in count\n      if (entity.isList?.()) {\n        listNamePaths.push(namePath);\n        return;\n      }\n      if (!mergedFilterFunc) {\n        filteredNameList.push(namePath);\n      } else {\n        const meta = 'getMeta' in entity ? entity.getMeta() : null;\n        if (mergedFilterFunc(meta)) {\n          filteredNameList.push(namePath);\n        }\n      }\n    });\n    let mergedValues = cloneByNamePathList(this.store, filteredNameList.map(getNamePath));\n\n    // We need fill the list as [] if Form.List is empty\n    listNamePaths.forEach(namePath => {\n      if (!getValue(mergedValues, namePath)) {\n        mergedValues = setValue(mergedValues, namePath, []);\n      }\n    });\n    return mergedValues;\n  };\n  getFieldValue = name => {\n    this.warningUnhooked();\n    const namePath = getNamePath(name);\n    return getValue(this.store, namePath);\n  };\n  getFieldsError = nameList => {\n    this.warningUnhooked();\n    const fieldEntities = this.getFieldEntitiesForNamePathList(nameList);\n    return fieldEntities.map((entity, index) => {\n      if (entity && !entity.INVALIDATE_NAME_PATH) {\n        return {\n          name: entity.getNamePath(),\n          errors: entity.getErrors(),\n          warnings: entity.getWarnings()\n        };\n      }\n      return {\n        name: getNamePath(nameList[index]),\n        errors: [],\n        warnings: []\n      };\n    });\n  };\n  getFieldError = name => {\n    this.warningUnhooked();\n    const namePath = getNamePath(name);\n    const fieldError = this.getFieldsError([namePath])[0];\n    return fieldError.errors;\n  };\n  getFieldWarning = name => {\n    this.warningUnhooked();\n    const namePath = getNamePath(name);\n    const fieldError = this.getFieldsError([namePath])[0];\n    return fieldError.warnings;\n  };\n  isFieldsTouched = (...args) => {\n    this.warningUnhooked();\n    const [arg0, arg1] = args;\n    let namePathList;\n    let isAllFieldsTouched = false;\n    if (args.length === 0) {\n      namePathList = null;\n    } else if (args.length === 1) {\n      if (Array.isArray(arg0)) {\n        namePathList = arg0.map(getNamePath);\n        isAllFieldsTouched = false;\n      } else {\n        namePathList = null;\n        isAllFieldsTouched = arg0;\n      }\n    } else {\n      namePathList = arg0.map(getNamePath);\n      isAllFieldsTouched = arg1;\n    }\n    const fieldEntities = this.getFieldEntities(true);\n    const isFieldTouched = field => field.isFieldTouched();\n\n    // ===== Will get fully compare when not config namePathList =====\n    if (!namePathList) {\n      return isAllFieldsTouched ? fieldEntities.every(entity => isFieldTouched(entity) || entity.isList()) : fieldEntities.some(isFieldTouched);\n    }\n\n    // Generate a nest tree for validate\n    const map = new NameMap();\n    namePathList.forEach(shortNamePath => {\n      map.set(shortNamePath, []);\n    });\n    fieldEntities.forEach(field => {\n      const fieldNamePath = field.getNamePath();\n\n      // Find matched entity and put into list\n      namePathList.forEach(shortNamePath => {\n        if (shortNamePath.every((nameUnit, i) => fieldNamePath[i] === nameUnit)) {\n          map.update(shortNamePath, list => [...list, field]);\n        }\n      });\n    });\n\n    // Check if NameMap value is touched\n    const isNamePathListTouched = entities => entities.some(isFieldTouched);\n    const namePathListEntities = map.map(({\n      value\n    }) => value);\n    return isAllFieldsTouched ? namePathListEntities.every(isNamePathListTouched) : namePathListEntities.some(isNamePathListTouched);\n  };\n  isFieldTouched = name => {\n    this.warningUnhooked();\n    return this.isFieldsTouched([name]);\n  };\n  isFieldsValidating = nameList => {\n    this.warningUnhooked();\n    const fieldEntities = this.getFieldEntities();\n    if (!nameList) {\n      return fieldEntities.some(testField => testField.isFieldValidating());\n    }\n    const namePathList = nameList.map(getNamePath);\n    return fieldEntities.some(testField => {\n      const fieldNamePath = testField.getNamePath();\n      return containsNamePath(namePathList, fieldNamePath) && testField.isFieldValidating();\n    });\n  };\n  isFieldValidating = name => {\n    this.warningUnhooked();\n    return this.isFieldsValidating([name]);\n  };\n\n  /**\n   * Reset Field with field `initialValue` prop.\n   * Can pass `entities` or `namePathList` or just nothing.\n   */\n  resetWithFieldInitialValue = (info = {}) => {\n    // Create cache\n    const cache = new NameMap();\n    const fieldEntities = this.getFieldEntities(true);\n    fieldEntities.forEach(field => {\n      const {\n        initialValue\n      } = field.props;\n      const namePath = field.getNamePath();\n\n      // Record only if has `initialValue`\n      if (initialValue !== undefined) {\n        const records = cache.get(namePath) || new Set();\n        records.add({\n          entity: field,\n          value: initialValue\n        });\n        cache.set(namePath, records);\n      }\n    });\n\n    // Reset\n    const resetWithFields = entities => {\n      entities.forEach(field => {\n        const {\n          initialValue\n        } = field.props;\n        if (initialValue !== undefined) {\n          const namePath = field.getNamePath();\n          const formInitialValue = this.getInitialValue(namePath);\n          if (formInitialValue !== undefined) {\n            // Warning if conflict with form initialValues and do not modify value\n            warning(false, `Form already set 'initialValues' with path '${namePath.join('.')}'. Field can not overwrite it.`);\n          } else {\n            const records = cache.get(namePath);\n            if (records && records.size > 1) {\n              // Warning if multiple field set `initialValue`and do not modify value\n              warning(false, `Multiple Field with path '${namePath.join('.')}' set 'initialValue'. Can not decide which one to pick.`);\n            } else if (records) {\n              const originValue = this.getFieldValue(namePath);\n              const isListField = field.isListField();\n\n              // Set `initialValue`\n              if (!isListField && (!info.skipExist || originValue === undefined)) {\n                this.updateStore(setValue(this.store, namePath, [...records][0].value));\n              }\n            }\n          }\n        }\n      });\n    };\n    let requiredFieldEntities;\n    if (info.entities) {\n      requiredFieldEntities = info.entities;\n    } else if (info.namePathList) {\n      requiredFieldEntities = [];\n      info.namePathList.forEach(namePath => {\n        const records = cache.get(namePath);\n        if (records) {\n          requiredFieldEntities.push(...[...records].map(r => r.entity));\n        }\n      });\n    } else {\n      requiredFieldEntities = fieldEntities;\n    }\n    resetWithFields(requiredFieldEntities);\n  };\n  resetFields = nameList => {\n    this.warningUnhooked();\n    const prevStore = this.store;\n    if (!nameList) {\n      this.updateStore(merge(this.initialValues));\n      this.resetWithFieldInitialValue();\n      this.notifyObservers(prevStore, null, {\n        type: 'reset'\n      });\n      this.notifyWatch();\n      return;\n    }\n\n    // Reset by `nameList`\n    const namePathList = nameList.map(getNamePath);\n    namePathList.forEach(namePath => {\n      const initialValue = this.getInitialValue(namePath);\n      this.updateStore(setValue(this.store, namePath, initialValue));\n    });\n    this.resetWithFieldInitialValue({\n      namePathList\n    });\n    this.notifyObservers(prevStore, namePathList, {\n      type: 'reset'\n    });\n    this.notifyWatch(namePathList);\n  };\n  setFields = fields => {\n    this.warningUnhooked();\n    const prevStore = this.store;\n    const namePathList = [];\n    fields.forEach(fieldData => {\n      const {\n        name,\n        ...data\n      } = fieldData;\n      const namePath = getNamePath(name);\n      namePathList.push(namePath);\n\n      // Value\n      if ('value' in data) {\n        this.updateStore(setValue(this.store, namePath, data.value));\n      }\n      this.notifyObservers(prevStore, [namePath], {\n        type: 'setField',\n        data: fieldData\n      });\n    });\n    this.notifyWatch(namePathList);\n  };\n  getFields = () => {\n    const entities = this.getFieldEntities(true);\n    const fields = entities.map(field => {\n      const namePath = field.getNamePath();\n      const meta = field.getMeta();\n      const fieldData = {\n        ...meta,\n        name: namePath,\n        value: this.getFieldValue(namePath)\n      };\n      Object.defineProperty(fieldData, 'originRCField', {\n        value: true\n      });\n      return fieldData;\n    });\n    return fields;\n  };\n\n  // =========================== Observer ===========================\n  /**\n   * This only trigger when a field is on constructor to avoid we get initialValue too late\n   */\n  initEntityValue = entity => {\n    const {\n      initialValue\n    } = entity.props;\n    if (initialValue !== undefined) {\n      const namePath = entity.getNamePath();\n      const prevValue = getValue(this.store, namePath);\n      if (prevValue === undefined) {\n        this.updateStore(setValue(this.store, namePath, initialValue));\n      }\n    }\n  };\n  isMergedPreserve = fieldPreserve => {\n    const mergedPreserve = fieldPreserve !== undefined ? fieldPreserve : this.preserve;\n    return mergedPreserve ?? true;\n  };\n  registerField = entity => {\n    this.fieldEntities.push(entity);\n    const namePath = entity.getNamePath();\n    this.batchNotifyWatch(namePath);\n\n    // Set initial values\n    if (entity.props.initialValue !== undefined) {\n      const prevStore = this.store;\n      this.resetWithFieldInitialValue({\n        entities: [entity],\n        skipExist: true\n      });\n      this.notifyObservers(prevStore, [entity.getNamePath()], {\n        type: 'valueUpdate',\n        source: 'internal'\n      });\n    }\n\n    // un-register field callback\n    return (isListField, preserve, subNamePath = []) => {\n      this.fieldEntities = this.fieldEntities.filter(item => item !== entity);\n\n      // Clean up store value if not preserve\n      if (!this.isMergedPreserve(preserve) && (!isListField || subNamePath.length > 1)) {\n        const defaultValue = isListField ? undefined : this.getInitialValue(namePath);\n        if (namePath.length && this.getFieldValue(namePath) !== defaultValue && this.fieldEntities.every(field =>\n        // Only reset when no namePath exist\n        !matchNamePath(field.getNamePath(), namePath))) {\n          const prevStore = this.store;\n          this.updateStore(setValue(prevStore, namePath, defaultValue, true));\n\n          // Notify that field is unmount\n          this.notifyObservers(prevStore, [namePath], {\n            type: 'remove'\n          });\n\n          // Dependencies update\n          this.triggerDependenciesUpdate(prevStore, namePath);\n        }\n      }\n      this.batchNotifyWatch(namePath);\n    };\n  };\n  dispatch = action => {\n    switch (action.type) {\n      case 'updateValue':\n        {\n          const {\n            namePath,\n            value\n          } = action;\n          this.updateValue(namePath, value);\n          break;\n        }\n      case 'validateField':\n        {\n          const {\n            namePath,\n            triggerName\n          } = action;\n          this.validateFields([namePath], {\n            triggerName\n          });\n          break;\n        }\n      default:\n      // Currently we don't have other action. Do nothing.\n    }\n  };\n  notifyObservers = (prevStore, namePathList, info) => {\n    if (this.subscribable) {\n      const mergedInfo = {\n        ...info,\n        store: this.getFieldsValue(true)\n      };\n      this.getFieldEntities().forEach(({\n        onStoreChange\n      }) => {\n        onStoreChange(prevStore, namePathList, mergedInfo);\n      });\n    } else {\n      this.forceRootUpdate();\n    }\n  };\n\n  /**\n   * Notify dependencies children with parent update\n   * We need delay to trigger validate in case Field is under render props\n   */\n  triggerDependenciesUpdate = (prevStore, namePath) => {\n    const childrenFields = this.getDependencyChildrenFields(namePath);\n    if (childrenFields.length) {\n      this.validateFields(childrenFields);\n    }\n    this.notifyObservers(prevStore, childrenFields, {\n      type: 'dependenciesUpdate',\n      relatedFields: [namePath, ...childrenFields]\n    });\n    return childrenFields;\n  };\n  updateValue = (name, value) => {\n    const namePath = getNamePath(name);\n    const prevStore = this.store;\n    this.updateStore(setValue(this.store, namePath, value));\n    this.notifyObservers(prevStore, [namePath], {\n      type: 'valueUpdate',\n      source: 'internal'\n    });\n    this.notifyWatch([namePath]);\n\n    // Dependencies update\n    const childrenFields = this.triggerDependenciesUpdate(prevStore, namePath);\n\n    // trigger callback function\n    const {\n      onValuesChange\n    } = this.callbacks;\n    if (onValuesChange) {\n      const changedValues = cloneByNamePathList(this.store, [namePath]);\n      const allValues = this.getFieldsValue();\n      // Merge changedValues into allValues to ensure allValues contains the latest changes\n      const mergedAllValues = merge(allValues, changedValues);\n      onValuesChange(changedValues, mergedAllValues);\n    }\n    this.triggerOnFieldsChange([namePath, ...childrenFields]);\n  };\n\n  // Let all child Field get update.\n  setFieldsValue = store => {\n    this.warningUnhooked();\n    const prevStore = this.store;\n    if (store) {\n      const nextStore = merge(this.store, store);\n      this.updateStore(nextStore);\n    }\n    this.notifyObservers(prevStore, null, {\n      type: 'valueUpdate',\n      source: 'external'\n    });\n    this.notifyWatch();\n  };\n  setFieldValue = (name, value) => {\n    this.setFields([{\n      name,\n      value,\n      errors: [],\n      warnings: [],\n      touched: true\n    }]);\n  };\n  getDependencyChildrenFields = rootNamePath => {\n    const children = new Set();\n    const childrenFields = [];\n    const dependencies2fields = new NameMap();\n\n    /**\n     * Generate maps\n     * Can use cache to save perf if user report performance issue with this\n     */\n    this.getFieldEntities().forEach(field => {\n      const {\n        dependencies\n      } = field.props;\n      (dependencies || []).forEach(dependency => {\n        const dependencyNamePath = getNamePath(dependency);\n        dependencies2fields.update(dependencyNamePath, (fields = new Set()) => {\n          fields.add(field);\n          return fields;\n        });\n      });\n    });\n    const fillChildren = namePath => {\n      const fields = dependencies2fields.get(namePath) || new Set();\n      fields.forEach(field => {\n        if (!children.has(field)) {\n          children.add(field);\n          const fieldNamePath = field.getNamePath();\n          if (field.isFieldDirty() && fieldNamePath.length) {\n            childrenFields.push(fieldNamePath);\n            fillChildren(fieldNamePath);\n          }\n        }\n      });\n    };\n    fillChildren(rootNamePath);\n    return childrenFields;\n  };\n  triggerOnFieldsChange = (namePathList, filedErrors) => {\n    const {\n      onFieldsChange\n    } = this.callbacks;\n    if (onFieldsChange) {\n      const fields = this.getFields();\n\n      /**\n       * Fill errors since `fields` may be replaced by controlled fields\n       */\n      if (filedErrors) {\n        const cache = new NameMap();\n        filedErrors.forEach(({\n          name,\n          errors\n        }) => {\n          cache.set(name, errors);\n        });\n        fields.forEach(field => {\n          // eslint-disable-next-line no-param-reassign\n          field.errors = cache.get(field.name) || field.errors;\n        });\n      }\n      const changedFields = fields.filter(({\n        name: fieldName\n      }) => containsNamePath(namePathList, fieldName));\n      if (changedFields.length) {\n        onFieldsChange(changedFields, fields);\n      }\n    }\n  };\n\n  // =========================== Validate ===========================\n  validateFields = (arg1, arg2) => {\n    this.warningUnhooked();\n    let nameList;\n    let options;\n    if (Array.isArray(arg1) || typeof arg1 === 'string' || typeof arg2 === 'string') {\n      nameList = arg1;\n      options = arg2;\n    } else {\n      options = arg1;\n    }\n    const provideNameList = !!nameList;\n    const namePathList = provideNameList ? nameList.map(getNamePath) : [];\n    // Same namePathList, but does not include Form.List name\n    const finalValueNamePathList = [...namePathList];\n\n    // Collect result in promise list\n    const promiseList = [];\n\n    // We temp save the path which need trigger for `onFieldsChange`\n    const TMP_SPLIT = String(Date.now());\n    const validateNamePathList = new Set();\n    const {\n      recursive,\n      dirty\n    } = options || {};\n    this.getFieldEntities(true).forEach(field => {\n      const fieldNamePath = field.getNamePath();\n\n      // Add field if not provide `nameList`\n      if (!provideNameList) {\n        if (\n        // If is field, pass directly\n        !field.isList() ||\n        // If is list, do not add if already exist sub field in the namePathList\n        !namePathList.some(name => matchNamePath(name, fieldNamePath, true))) {\n          finalValueNamePathList.push(fieldNamePath);\n        }\n        namePathList.push(fieldNamePath);\n      }\n\n      // Skip if without rule\n      if (!field.props.rules || !field.props.rules.length) {\n        return;\n      }\n\n      // Skip if only validate dirty field\n      if (dirty && !field.isFieldDirty()) {\n        return;\n      }\n      validateNamePathList.add(fieldNamePath.join(TMP_SPLIT));\n\n      // Add field validate rule in to promise list\n      if (!provideNameList || containsNamePath(namePathList, fieldNamePath, recursive)) {\n        const promise = field.validateRules({\n          validateMessages: {\n            ...defaultValidateMessages,\n            ...this.validateMessages\n          },\n          ...options\n        });\n\n        // Wrap promise with field\n        promiseList.push(promise.then(() => ({\n          name: fieldNamePath,\n          errors: [],\n          warnings: []\n        })).catch(ruleErrors => {\n          const mergedErrors = [];\n          const mergedWarnings = [];\n          ruleErrors.forEach?.(({\n            rule: {\n              warningOnly\n            },\n            errors\n          }) => {\n            if (warningOnly) {\n              mergedWarnings.push(...errors);\n            } else {\n              mergedErrors.push(...errors);\n            }\n          });\n          if (mergedErrors.length) {\n            return Promise.reject({\n              name: fieldNamePath,\n              errors: mergedErrors,\n              warnings: mergedWarnings\n            });\n          }\n          return {\n            name: fieldNamePath,\n            errors: mergedErrors,\n            warnings: mergedWarnings\n          };\n        }));\n      }\n    });\n    const summaryPromise = allPromiseFinish(promiseList);\n    this.lastValidatePromise = summaryPromise;\n\n    // Notify fields with rule that validate has finished and need update\n    summaryPromise.catch(results => results).then(results => {\n      const resultNamePathList = results.map(({\n        name\n      }) => name);\n      this.notifyObservers(this.store, resultNamePathList, {\n        type: 'validateFinish'\n      });\n      this.triggerOnFieldsChange(resultNamePathList, results);\n    });\n    const returnPromise = summaryPromise.then(() => {\n      if (this.lastValidatePromise === summaryPromise) {\n        return Promise.resolve(this.getFieldsValue(finalValueNamePathList));\n      }\n      return Promise.reject([]);\n    }).catch(results => {\n      const errorList = results.filter(result => result && result.errors.length);\n      const errorMessage = errorList[0]?.errors?.[0];\n      return Promise.reject({\n        message: errorMessage,\n        values: this.getFieldsValue(namePathList),\n        errorFields: errorList,\n        outOfDate: this.lastValidatePromise !== summaryPromise\n      });\n    });\n\n    // Do not throw in console\n    returnPromise.catch(e => e);\n\n    // `validating` changed. Trigger `onFieldsChange`\n    const triggerNamePathList = namePathList.filter(namePath => validateNamePathList.has(namePath.join(TMP_SPLIT)));\n    this.triggerOnFieldsChange(triggerNamePathList);\n    return returnPromise;\n  };\n\n  // ============================ Submit ============================\n  submit = () => {\n    this.warningUnhooked();\n    this.validateFields().then(values => {\n      const {\n        onFinish\n      } = this.callbacks;\n      if (onFinish) {\n        try {\n          onFinish(values);\n        } catch (err) {\n          // Should print error if user `onFinish` callback failed\n          console.error(err);\n        }\n      }\n    }).catch(e => {\n      const {\n        onFinishFailed\n      } = this.callbacks;\n      if (onFinishFailed) {\n        onFinishFailed(e);\n      }\n    });\n  };\n}\nfunction useForm(form) {\n  const formRef = React.useRef(null);\n  const [, forceUpdate] = React.useState({});\n  if (!formRef.current) {\n    if (form) {\n      formRef.current = form;\n    } else {\n      // Create a new FormStore if not provided\n      const forceReRender = () => {\n        forceUpdate({});\n      };\n      const formStore = new FormStore(forceReRender);\n      formRef.current = formStore.getForm();\n    }\n  }\n  return [formRef.current];\n}\nexport default useForm;"],"names":[],"mappings":"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","ignoreList":[0],"debugId":null}},
    {"offset": {"line": 2177, "column": 0}, "map": {"version":3,"sources":["file:///Users/best/Documents/admin-frontend-next/www/node_modules/%40rc-component/form/es/FormContext.js"],"sourcesContent":["import * as React from 'react';\nconst FormContext = /*#__PURE__*/React.createContext({\n  triggerFormChange: () => {},\n  triggerFormFinish: () => {},\n  registerForm: () => {},\n  unregisterForm: () => {}\n});\nconst FormProvider = ({\n  validateMessages,\n  onFormChange,\n  onFormFinish,\n  children\n}) => {\n  const formContext = React.useContext(FormContext);\n  const formsRef = React.useRef({});\n  return /*#__PURE__*/React.createElement(FormContext.Provider, {\n    value: {\n      ...formContext,\n      validateMessages: {\n        ...formContext.validateMessages,\n        ...validateMessages\n      },\n      // =========================================================\n      // =                  Global Form Control                  =\n      // =========================================================\n      triggerFormChange: (name, changedFields) => {\n        if (onFormChange) {\n          onFormChange(name, {\n            changedFields,\n            forms: formsRef.current\n          });\n        }\n        formContext.triggerFormChange(name, changedFields);\n      },\n      triggerFormFinish: (name, values) => {\n        if (onFormFinish) {\n          onFormFinish(name, {\n            values,\n            forms: formsRef.current\n          });\n        }\n        formContext.triggerFormFinish(name, values);\n      },\n      registerForm: (name, form) => {\n        if (name) {\n          formsRef.current = {\n            ...formsRef.current,\n            [name]: form\n          };\n        }\n        formContext.registerForm(name, form);\n      },\n      unregisterForm: name => {\n        const newForms = {\n          ...formsRef.current\n        };\n        delete newForms[name];\n        formsRef.current = newForms;\n        formContext.unregisterForm(name);\n      }\n    }\n  }, children);\n};\nexport { FormProvider };\nexport default FormContext;"],"names":[],"mappings":";;;;;;AAAA;;AACA,MAAM,cAAc,WAAW,GAAE,+NAAmB,CAAC;IACnD,mBAAmB,KAAO;IAC1B,mBAAmB,KAAO;IAC1B,cAAc,KAAO;IACrB,gBAAgB,KAAO;AACzB;AACA,MAAM,eAAe;QAAC,EACpB,gBAAgB,EAChB,YAAY,EACZ,YAAY,EACZ,QAAQ,EACT;IACC,MAAM,cAAc,4NAAgB,CAAC;IACrC,MAAM,WAAW,wNAAY,CAAC,CAAC;IAC/B,OAAO,WAAW,GAAE,+NAAmB,CAAC,YAAY,QAAQ,EAAE;QAC5D,OAAO;YACL,GAAG,WAAW;YACd,kBAAkB;gBAChB,GAAG,YAAY,gBAAgB;gBAC/B,GAAG,gBAAgB;YACrB;YACA,4DAA4D;YAC5D,4DAA4D;YAC5D,4DAA4D;YAC5D,mBAAmB,CAAC,MAAM;gBACxB,IAAI,cAAc;oBAChB,aAAa,MAAM;wBACjB;wBACA,OAAO,SAAS,OAAO;oBACzB;gBACF;gBACA,YAAY,iBAAiB,CAAC,MAAM;YACtC;YACA,mBAAmB,CAAC,MAAM;gBACxB,IAAI,cAAc;oBAChB,aAAa,MAAM;wBACjB;wBACA,OAAO,SAAS,OAAO;oBACzB;gBACF;gBACA,YAAY,iBAAiB,CAAC,MAAM;YACtC;YACA,cAAc,CAAC,MAAM;gBACnB,IAAI,MAAM;oBACR,SAAS,OAAO,GAAG;wBACjB,GAAG,SAAS,OAAO;wBACnB,CAAC,KAAK,EAAE;oBACV;gBACF;gBACA,YAAY,YAAY,CAAC,MAAM;YACjC;YACA,gBAAgB,CAAA;gBACd,MAAM,WAAW;oBACf,GAAG,SAAS,OAAO;gBACrB;gBACA,OAAO,QAAQ,CAAC,KAAK;gBACrB,SAAS,OAAO,GAAG;gBACnB,YAAY,cAAc,CAAC;YAC7B;QACF;IACF,GAAG;AACL;;uCAEe","ignoreList":[0],"debugId":null}},
    {"offset": {"line": 2249, "column": 0}, "map": {"version":3,"sources":["file:///Users/best/Documents/admin-frontend-next/www/node_modules/%40rc-component/form/es/BatchUpdate.js"],"sourcesContent":["import * as React from 'react';\nconst BatchUpdate = /*#__PURE__*/React.forwardRef((_, ref) => {\n  const [batchInfo, setBatchInfo] = React.useState({});\n  React.useLayoutEffect(() => {\n    const keys = Object.keys(batchInfo);\n    if (keys.length) {\n      keys.forEach(key => {\n        batchInfo[key]?.();\n      });\n      setBatchInfo({});\n    }\n  }, [batchInfo]);\n  React.useImperativeHandle(ref, () => ({\n    batch: (key, callback) => {\n      setBatchInfo(ori => ({\n        ...ori,\n        [key]: callback\n      }));\n    }\n  }));\n  return null;\n});\nexport default BatchUpdate;"],"names":[],"mappings":";;;;AAAA;;AACA,MAAM,cAAc,WAAW,GAAE,4NAAgB,CAAC,CAAC,GAAG;IACpD,MAAM,CAAC,WAAW,aAAa,GAAG,0NAAc,CAAC,CAAC;IAClD,iOAAqB;uCAAC;YACpB,MAAM,OAAO,OAAO,IAAI,CAAC;YACzB,IAAI,KAAK,MAAM,EAAE;gBACf,KAAK,OAAO;mDAAC,CAAA;4BACX;yBAAA,iBAAA,SAAS,CAAC,IAAI,cAAd,qCAAA,oBAAA;oBACF;;gBACA,aAAa,CAAC;YAChB;QACF;sCAAG;QAAC;KAAU;IACd,qOAAyB,CAAC;2CAAK,IAAM,CAAC;gBACpC,KAAK;uDAAE,CAAC,KAAK;wBACX;+DAAa,CAAA,MAAO,CAAC;oCACnB,GAAG,GAAG;oCACN,CAAC,IAAI,EAAE;gCACT,CAAC;;oBACH;;YACF,CAAC;;IACD,OAAO;AACT;uCACe","ignoreList":[0],"debugId":null}},
    {"offset": {"line": 2294, "column": 0}, "map": {"version":3,"sources":["file:///Users/best/Documents/admin-frontend-next/www/node_modules/%40rc-component/form/es/Form.js"],"sourcesContent":["function _extends() { _extends = Object.assign ? Object.assign.bind() : function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; }; return _extends.apply(this, arguments); }\nimport * as React from 'react';\nimport useForm from \"./useForm\";\nimport FieldContext, { HOOK_MARK } from \"./FieldContext\";\nimport FormContext from \"./FormContext\";\nimport { isSimilar } from \"./utils/valueUtil\";\nimport ListContext from \"./ListContext\";\nimport BatchUpdate from \"./BatchUpdate\";\nconst Form = ({\n  name,\n  initialValues,\n  fields,\n  form,\n  preserve,\n  children,\n  component: Component = 'form',\n  validateMessages,\n  validateTrigger = 'onChange',\n  onValuesChange,\n  onFieldsChange,\n  onFinish,\n  onFinishFailed,\n  clearOnDestroy,\n  ...restProps\n}, ref) => {\n  const nativeElementRef = React.useRef(null);\n  const formContext = React.useContext(FormContext);\n\n  // We customize handle event since Context will makes all the consumer re-render:\n  // https://reactjs.org/docs/context.html#contextprovider\n  const [formInstance] = useForm(form);\n  const {\n    useSubscribe,\n    setInitialValues,\n    setCallbacks,\n    setValidateMessages,\n    setPreserve,\n    destroyForm,\n    setBatchUpdate\n  } = formInstance.getInternalHooks(HOOK_MARK);\n\n  // Pass ref with form instance\n  React.useImperativeHandle(ref, () => ({\n    ...formInstance,\n    nativeElement: nativeElementRef.current\n  }));\n\n  // Register form into Context\n  React.useEffect(() => {\n    formContext.registerForm(name, formInstance);\n    return () => {\n      formContext.unregisterForm(name);\n    };\n  }, [formContext, formInstance, name]);\n\n  // Pass props to store\n  setValidateMessages({\n    ...formContext.validateMessages,\n    ...validateMessages\n  });\n  setCallbacks({\n    onValuesChange,\n    onFieldsChange: (changedFields, ...rest) => {\n      formContext.triggerFormChange(name, changedFields);\n      if (onFieldsChange) {\n        onFieldsChange(changedFields, ...rest);\n      }\n    },\n    onFinish: values => {\n      formContext.triggerFormFinish(name, values);\n      if (onFinish) {\n        onFinish(values);\n      }\n    },\n    onFinishFailed\n  });\n  setPreserve(preserve);\n\n  // Set initial value, init store value when first mount\n  const mountRef = React.useRef(null);\n  setInitialValues(initialValues, !mountRef.current);\n  if (!mountRef.current) {\n    mountRef.current = true;\n  }\n\n  // ======================== Batch Update ========================\n  // zombieJ:\n  // To avoid Form self re-render,\n  // We create a sub component `BatchUpdate` to handle batch update logic.\n  // When the call with do not change immediate, we will batch the update\n  // and flush it in `useLayoutEffect` for next tick.\n\n  // Set batch update ref\n  const batchUpdateRef = React.useRef(null);\n  const batchUpdateTasksRef = React.useRef([]);\n  const tryFlushBatch = () => {\n    if (batchUpdateRef.current) {\n      batchUpdateTasksRef.current.forEach(([key, fn]) => {\n        batchUpdateRef.current.batch(key, fn);\n      });\n      batchUpdateTasksRef.current = [];\n    }\n  };\n\n  // Ref update\n  const setBatchUpdateRef = React.useCallback(batchUpdate => {\n    batchUpdateRef.current = batchUpdate;\n    tryFlushBatch();\n  }, []);\n\n  // Task list\n\n  const batchUpdate = (key, callback) => {\n    batchUpdateTasksRef.current.push([key, callback]);\n    tryFlushBatch();\n  };\n  setBatchUpdate(batchUpdate);\n\n  // ========================== Unmount ===========================\n  React.useEffect(() => () => destroyForm(clearOnDestroy),\n  // eslint-disable-next-line react-hooks/exhaustive-deps\n  []);\n\n  // Prepare children by `children` type\n  let childrenNode;\n  const childrenRenderProps = typeof children === 'function';\n  if (childrenRenderProps) {\n    const values = formInstance.getFieldsValue(true);\n    childrenNode = children(values, formInstance);\n  } else {\n    childrenNode = children;\n  }\n\n  // Not use subscribe when using render props\n  useSubscribe(!childrenRenderProps);\n\n  // Listen if fields provided. We use ref to save prev data here to avoid additional render\n  const prevFieldsRef = React.useRef(null);\n  React.useEffect(() => {\n    if (!isSimilar(prevFieldsRef.current || [], fields || [])) {\n      formInstance.setFields(fields || []);\n    }\n    prevFieldsRef.current = fields;\n  }, [fields, formInstance]);\n\n  // =========================== Render ===========================\n  const formContextValue = React.useMemo(() => ({\n    ...formInstance,\n    validateTrigger\n  }), [formInstance, validateTrigger]);\n  const wrapperNode = /*#__PURE__*/React.createElement(ListContext.Provider, {\n    value: null\n  }, /*#__PURE__*/React.createElement(FieldContext.Provider, {\n    value: formContextValue\n  }, childrenNode), /*#__PURE__*/React.createElement(BatchUpdate, {\n    ref: setBatchUpdateRef\n  }));\n  if (Component === false) {\n    return wrapperNode;\n  }\n  return /*#__PURE__*/React.createElement(Component, _extends({}, restProps, {\n    ref: nativeElementRef,\n    onSubmit: event => {\n      event.preventDefault();\n      event.stopPropagation();\n      formInstance.submit();\n    },\n    onReset: event => {\n      event.preventDefault();\n      formInstance.resetFields();\n      restProps.onReset?.(event);\n    }\n  }), wrapperNode);\n};\nexport default Form;"],"names":[],"mappings":"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","ignoreList":[0],"debugId":null}},
    {"offset": {"line": 2482, "column": 0}, "map": {"version":3,"sources":["file:///Users/best/Documents/admin-frontend-next/www/node_modules/%40rc-component/form/es/useWatch.js"],"sourcesContent":["import warning from \"@rc-component/util/es/warning\";\nimport { useContext, useEffect, useMemo, useRef, useState } from 'react';\nimport FieldContext, { HOOK_MARK } from \"./FieldContext\";\nimport { isFormInstance } from \"./utils/typeUtil\";\nimport { getNamePath, getValue } from \"./utils/valueUtil\";\nimport { useEvent } from '@rc-component/util';\nexport function stringify(value) {\n  try {\n    return JSON.stringify(value);\n  } catch {\n    return Math.random();\n  }\n}\n\n// ------- selector type -------\n\n// ------- selector type end -------\n\nfunction useWatch(...args) {\n  const [dependencies, _form = {}] = args;\n  const options = isFormInstance(_form) ? {\n    form: _form\n  } : _form;\n  const form = options.form;\n  const [value, setValue] = useState(() => typeof dependencies === 'function' ? dependencies({}) : undefined);\n  const valueStr = useMemo(() => stringify(value), [value]);\n  const valueStrRef = useRef(valueStr);\n  valueStrRef.current = valueStr;\n  const fieldContext = useContext(FieldContext);\n  const formInstance = form || fieldContext;\n  const isValidForm = formInstance && formInstance._init;\n\n  // Warning if not exist form instance\n  if (process.env.NODE_ENV !== 'production') {\n    warning(args.length === 2 ? form ? isValidForm : true : isValidForm, 'useWatch requires a form instance since it can not auto detect from context.');\n  }\n\n  // ============================== Form ==============================\n  const {\n    getFieldsValue,\n    getInternalHooks\n  } = formInstance;\n  const {\n    registerWatch\n  } = getInternalHooks(HOOK_MARK);\n\n  // ============================= Update =============================\n  const triggerUpdate = useEvent((values, allValues) => {\n    const watchValue = options.preserve ? allValues ?? getFieldsValue(true) : values ?? getFieldsValue();\n    const nextValue = typeof dependencies === 'function' ? dependencies(watchValue) : getValue(watchValue, getNamePath(dependencies));\n    if (stringify(value) !== stringify(nextValue)) {\n      setValue(nextValue);\n    }\n  });\n\n  // ============================= Effect =============================\n  const flattenDeps = typeof dependencies === 'function' ? dependencies : JSON.stringify(dependencies);\n\n  // Deps changed\n  useEffect(() => {\n    // Skip if not exist form instance\n    if (!isValidForm) {\n      return;\n    }\n    triggerUpdate();\n\n    // eslint-disable-next-line react-hooks/exhaustive-deps\n  }, [isValidForm, flattenDeps]);\n\n  // Value changed\n  useEffect(() => {\n    // Skip if not exist form instance\n    if (!isValidForm) {\n      return;\n    }\n    const cancelRegister = registerWatch((values, allValues) => {\n      triggerUpdate(values, allValues);\n    });\n    return cancelRegister;\n\n    // eslint-disable-next-line react-hooks/exhaustive-deps\n  }, [isValidForm]);\n  return value;\n}\nexport default useWatch;"],"names":[],"mappings":";;;;;;AAiCM;AAjCN;AACA;AACA;AACA;AACA;AAAA;AACA;AAAA;;;;;;;AACO,SAAS,UAAU,KAAK;IAC7B,IAAI;QACF,OAAO,KAAK,SAAS,CAAC;IACxB,EAAE,UAAM;QACN,OAAO,KAAK,MAAM;IACpB;AACF;AAEA,gCAAgC;AAEhC,oCAAoC;AAEpC,SAAS;IAAS,IAAA,IAAA,OAAA,UAAA,QAAA,AAAG,OAAH,UAAA,OAAA,OAAA,GAAA,OAAA,MAAA;QAAG,KAAH,QAAA,SAAA,CAAA,KAAO;;IACvB,MAAM,CAAC,cAAc,QAAQ,CAAC,CAAC,CAAC,GAAG;IACnC,MAAM,UAAU,IAAA,0OAAc,EAAC,SAAS;QACtC,MAAM;IACR,IAAI;IACJ,MAAM,OAAO,QAAQ,IAAI;IACzB,MAAM,CAAC,OAAO,SAAS,GAAG,IAAA,0NAAQ;6BAAC,IAAM,OAAO,iBAAiB,aAAa,aAAa,CAAC,KAAK;;IACjG,MAAM,WAAW,IAAA,yNAAO;sCAAC,IAAM,UAAU;qCAAQ;QAAC;KAAM;IACxD,MAAM,cAAc,IAAA,wNAAM,EAAC;IAC3B,YAAY,OAAO,GAAG;IACtB,MAAM,eAAe,IAAA,4NAAU,EAAC,8NAAY;IAC5C,MAAM,eAAe,QAAQ;IAC7B,MAAM,cAAc,gBAAgB,aAAa,KAAK;IAEtD,qCAAqC;IACrC,wCAA2C;QACzC,IAAA,yNAAO,EAAC,KAAK,MAAM,KAAK,IAAI,OAAO,cAAc,OAAO,aAAa;IACvE;IAEA,qEAAqE;IACrE,MAAM,EACJ,cAAc,EACd,gBAAgB,EACjB,GAAG;IACJ,MAAM,EACJ,aAAa,EACd,GAAG,iBAAiB,gOAAS;IAE9B,qEAAqE;IACrE,MAAM,gBAAgB,IAAA,2QAAQ;4CAAC,CAAC,QAAQ;YACtC,MAAM,aAAa,QAAQ,QAAQ,GAAG,sBAAA,uBAAA,YAAa,eAAe,QAAQ,mBAAA,oBAAA,SAAU;YACpF,MAAM,YAAY,OAAO,iBAAiB,aAAa,aAAa,cAAc,IAAA,sQAAQ,EAAC,YAAY,IAAA,wPAAW,EAAC;YACnH,IAAI,UAAU,WAAW,UAAU,YAAY;gBAC7C,SAAS;YACX;QACF;;IAEA,qEAAqE;IACrE,MAAM,cAAc,OAAO,iBAAiB,aAAa,eAAe,KAAK,SAAS,CAAC;IAEvF,eAAe;IACf,IAAA,2NAAS;8BAAC;YACR,kCAAkC;YAClC,IAAI,CAAC,aAAa;gBAChB;YACF;YACA;QAEA,uDAAuD;QACzD;6BAAG;QAAC;QAAa;KAAY;IAE7B,gBAAgB;IAChB,IAAA,2NAAS;8BAAC;YACR,kCAAkC;YAClC,IAAI,CAAC,aAAa;gBAChB;YACF;YACA,MAAM,iBAAiB;qDAAc,CAAC,QAAQ;oBAC5C,cAAc,QAAQ;gBACxB;;YACA,OAAO;QAEP,uDAAuD;QACzD;6BAAG;QAAC;KAAY;IAChB,OAAO;AACT;uCACe","ignoreList":[0],"debugId":null}},
    {"offset": {"line": 2592, "column": 0}, "map": {"version":3,"sources":["file:///Users/best/Documents/admin-frontend-next/www/node_modules/%40rc-component/form/es/index.js"],"sourcesContent":["import * as React from 'react';\nimport Field from \"./Field\";\nimport List from \"./List\";\nimport useForm from \"./useForm\";\nimport FieldForm from \"./Form\";\nimport { FormProvider } from \"./FormContext\";\nimport FieldContext from \"./FieldContext\";\nimport ListContext from \"./ListContext\";\nimport useWatch from \"./useWatch\";\nconst InternalForm = /*#__PURE__*/React.forwardRef(FieldForm);\nconst RefForm = InternalForm;\nRefForm.FormProvider = FormProvider;\nRefForm.Field = Field;\nRefForm.List = List;\nRefForm.useForm = useForm;\nRefForm.useWatch = useWatch;\nexport { Field, List, useForm, FormProvider, FieldContext, ListContext, useWatch };\nexport default RefForm;"],"names":[],"mappings":";;;;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;AACA,MAAM,eAAe,WAAW,GAAE,4NAAgB,CAAC,sNAAS;AAC5D,MAAM,UAAU;AAChB,QAAQ,YAAY,GAAG,kOAAY;AACnC,QAAQ,KAAK,GAAG,uNAAK;AACrB,QAAQ,IAAI,GAAG,sNAAI;AACnB,QAAQ,OAAO,GAAG,yNAAO;AACzB,QAAQ,QAAQ,GAAG,0NAAQ;;uCAEZ","ignoreList":[0],"debugId":null}}]
}